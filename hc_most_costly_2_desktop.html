<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Health Check Most costly queries -> Neo4j Desktop Saved Cypher</title>
  <style>
    :root {
      --bg: #0b1020;
      --panel: #121a33;
      --panel-2: #0f1730;
      --text: #e8eeff;
      --muted: #a9b4d6;
      --border: rgba(255,255,255,0.14);
      --accent: #6aa8ff;
      --good: #2de39c;
      --bad: #ff5c7a;
    }

    body {
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      background: radial-gradient(1200px 800px at 20% 0%, #15224a 0%, var(--bg) 60%);
      color: var(--text);
    }

    .wrap {
      max-width: 1200px;
      margin: 0 auto;
      padding: 28px 18px 40px;
    }

    h1 {
      font-size: 22px;
      margin: 0 0 14px;
      letter-spacing: 0.2px;
      font-weight: 700;
    }

    .row {
      display: grid;
      grid-template-columns: 1fr;
      gap: 12px;
    }

    .card {
      background: linear-gradient(180deg, rgba(255,255,255,0.04), rgba(255,255,255,0.02));
      border: 1px solid var(--border);
      border-radius: 18px;
      padding: 14px;
      box-shadow: 0 12px 30px rgba(0,0,0,0.35);
    }

    .topbar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      flex-wrap: wrap;
    }

    .meta {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .muted { color: var(--muted); font-size: 13px; }

    .btns {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
    }

    button {
      background: rgba(255,255,255,0.06);
      border: 1px solid var(--border);
      color: var(--text);
      padding: 10px 12px;
      border-radius: 12px;
      cursor: pointer;
      font-weight: 600;
      transition: transform 120ms ease, background 120ms ease;
    }

    button:hover { transform: translateY(-1px); background: rgba(255,255,255,0.09); }
    button:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }

    .dropzone {
      display: grid;
      place-items: center;
      padding: 28px;
      background: linear-gradient(180deg, rgba(106,168,255,0.10), rgba(255,255,255,0.02));
      border: 2px dashed rgba(106,168,255,0.45);
      border-radius: 18px;
      text-align: center;
      user-select: none;
    }

    .dropzone.dragover {
      border-color: rgba(45,227,156,0.8);
      background: linear-gradient(180deg, rgba(45,227,156,0.14), rgba(255,255,255,0.02));
    }

    .dropzone strong { color: var(--accent); }

    .status {
      margin-top: 10px;
      font-size: 13px;
      color: var(--muted);
      display: flex;
      align-items: center;
      gap: 8px;
      justify-content: center;
      min-height: 18px;
      flex-wrap: wrap;
    }

    .pill {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.05);
      font-size: 12px;
      color: var(--muted);
    }

    .pill.good { color: var(--good); border-color: rgba(45,227,156,0.35); }
    .pill.bad { color: var(--bad); border-color: rgba(255,92,122,0.35); }

    .table-top {
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      gap: 12px;
      flex-wrap: wrap;
      margin-bottom: 10px;
    }

    .table-actions {
      display: flex;
      align-items: flex-start;
      justify-content: flex-end;
      gap: 24px;
      flex-wrap: wrap;
    }

    .btn-export {
      margin-top: 10px; /* vertical spacing above the button */
    }

    .import-help {
      max-width: 520px;
      text-align: right;
      line-height: 1.35;
      margin-top: 2px;
    }

    .import-icon {
      margin: 0 6px;
      vertical-align: -3px;
      fill: none;
      stroke: currentColor;
      stroke-width: 1.6;
      stroke-linecap: round;
      stroke-linejoin: round;
    }

    .table-wrap {
      overflow: auto;
      border-radius: 14px;
      border: 1px solid var(--border);
      background: rgba(0,0,0,0.12);
      max-height: 400px;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      min-width: 900px;
    }

    thead th {
      position: sticky;
      top: 0;
      background: rgba(18,26,51,0.95);
      backdrop-filter: blur(6px);
      border-bottom: 1px solid var(--border);
      text-align: left;
      padding: 10px 12px;
      font-size: 12px;
      color: var(--muted);
      letter-spacing: 0.3px;
      text-transform: uppercase;
      white-space: nowrap;
    }

    tbody td {
      border-bottom: 1px solid rgba(255,255,255,0.07);
      padding: 10px 12px;
      vertical-align: top;
      font-size: 13px;
      line-height: 1.35;
    }

    tbody tr:hover td { background: rgba(255,255,255,0.04); }

    .mono {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      white-space: pre-wrap;
      word-break: break-word;
    }

    .right { text-align: right; white-space: nowrap; }

    .data-content {
      display: grid;
      grid-template-columns: 1fr 320px;
      gap: 12px;
      align-items: start;
    }

    @media (max-width: 1400px) {
      .data-content {
        grid-template-columns: 1fr;
      }
    }

    .tree-panel {
      border: 1px solid var(--border);
      border-radius: 14px;
      background: rgba(0,0,0,0.12);
      overflow: auto;
      max-height: 600px;
      font-size: 13px;
    }

    .tree-panel-header {
      padding: 10px 12px;
      border-bottom: 1px solid var(--border);
      background: rgba(18,26,51,0.95);
      position: sticky;
      top: 0;
      font-weight: 700;
      color: var(--muted);
      text-transform: uppercase;
      font-size: 12px;
      letter-spacing: 0.3px;
      white-space: nowrap;
    }

    .tree-content {
      padding: 8px 0;
    }

    .tree-item {
      padding: 6px 8px;
      display: flex;
      align-items: center;
      gap: 6px;
      cursor: pointer;
      user-select: none;
      color: var(--muted);
      transition: color 120ms ease, background 120ms ease;
    }

    .tree-item:hover {
      background: rgba(255,255,255,0.06);
      color: var(--text);
    }

    .tree-item.folder {
      color: var(--accent);
    }

    .tree-item.folder:hover {
      color: #8ab8ff;
    }

    .tree-icon {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 18px;
      height: 18px;
      flex-shrink: 0;
      font-size: 11px;
      font-weight: 700;
      color: currentColor;
      transition: transform 100ms ease;
    }

    .tree-item.collapsed .tree-icon {
      transform: rotate(-90deg);
    }

    .tree-name {
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      flex-grow: 1;
    }

    .tree-children {
      display: none;
    }

    .tree-item.expanded ~ .tree-children {
      display: block;
    }

    .tree-children {
      padding-left: 18px;
    }

    .model-form {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .model-section {
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 10px;
      background: rgba(0,0,0,0.05);
    }

    .model-item {
      /* margin-bottom: 8px; */
    }

    .model-item label {
      display: flex;
      align-items: center;
      gap: 8px;
      font-weight: 600;
    }

    .model-item input[type="range"] {
      flex: 1;
      max-width: 200px;
    }

    .rel-row {
      display: grid;
      grid-template-columns: 1fr 2fr 1fr 1fr;
      gap: 12px;
      align-items: center;
      padding: 8px 0;
      border-bottom: 1px solid rgba(255,255,255,0.1);
    }

    .rel-type {
      font-weight: 600;
      color: var(--accent);
    }

    .rel-count {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .rel-count input[type="range"] {
      flex: 1;
      max-width: 150px;
    }

    .rel-source, .rel-target {
      min-width: 0;
    }

    .rel-source select, .rel-target select {
      width: 100%;
      min-width: 120px;
    }

    .node-row {
      display: grid;
      grid-template-columns: 1fr 2fr;
      gap: 12px;
      align-items: center;
      padding: 8px 0;
      border-bottom: 1px solid rgba(255,255,255,0.1);
    }

    .node-label {
      font-weight: 600;
      color: var(--accent);
    }

    .node-count {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .node-count input[type="range"] {
      flex: 1;
      max-width: 200px;
    }

    .model-table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 8px;
    }

    .model-table th, .model-table td {
      border: 1px solid var(--border);
      padding: 6px;
      text-align: left;
    }

    .model-table th {
      background: rgba(0,0,0,0.1);
      font-weight: 600;
    }

    .model-table select, .model-table input {
      width: 100%;
    }

    .config-cell {
      min-width: 200px;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Health Check Most costly queries -> Neo4j Desktop Saved Cypher</h1>

    <div class="row">
      <div class="card">
        <div class="topbar">
          <div class="meta">
            <div class="muted">Drop a Health Check report <strong>.zip</strong> file.</div>
            <div id="fileMeta" class="muted">No file loaded.</div>
          </div>
          <div class="btns">
            <button id="btnPick" type="button">Choose zip…</button>
            <input id="fileInput" type="file" accept=".zip,application/zip" style="display:none" />
            <span id="countPill" class="pill">0 rows</span>
          </div>
        </div>

        <div id="dropzone" class="dropzone" style="margin-top: 12px;">
          <div>
            <div style="font-size: 16px; font-weight: 700;">Drop your zip here</div>
            <div class="muted" style="margin-top: 6px;">Or click <strong>Choose zip…</strong></div>
            <div id="status" class="status"></div>
          </div>
        </div>
      </div>

      <div class="card">
        <div class="table-top">
          <div style="font-weight: 700;">Most Costly Queries</div>
          <div class="table-actions">
            <button id="btnExport" class="btn-export" type="button" disabled>Export CSV for Neo4j Browser/Query</button>
            <div class="muted import-help">
              <strong>Import into Neo4j Browser or Query:</strong> open the <em>Saved Cypher</em> panel, click the <em>Import saved cypher</em> icon
              <svg class="import-icon" title="Import saved cypher" aria-label="Import saved cypher" width="18" height="18" viewBox="0 0 24 24">
                <!-- Up arrow coming out of a thin tray (plate-like) -->
                <path d="M12 17V6" />
                <path d="M8.5 9.5 12 6l3.5 3.5" />
                <path d="M5 19h14" />
                <path d="M5 19v-1.4" />
                <path d="M19 19v-1.4" />
              </svg>
              and select the exported CSV file.
            </div>
          </div>
        </div>

        <div class="data-content">
          <div class="table-wrap">
            <table>
              <thead>
                <tr>
                  <th>instance</th>
                  <th>query_name</th>
                  <th>cypher</th>
                  <th class="right">Cumulative Execution Time</th>
                </tr>
              </thead>
              <tbody id="tbody">
                <tr><td colspan="4" class="muted">Drop a Health Check report .zip file to load data.</td></tr>
              </tbody>
            </table>
          </div>

          <div class="tree-panel">
            <div class="tree-panel-header">Target "Saved Cypher" Hierarchy</div>
            <div id="treeView" class="tree-content">
              <div class="muted" style="padding: 8px 12px; font-size: 12px;">Load data to view tree</div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="row">
      <div class="card">
        <h2>Model Information</h2>
        <div id="modelInfo">No model data loaded.</div>
      </div>
    </div>
  </div>

  <script>
    /**
     * Fix for: TypeError: Cannot set properties of null (setting 'textContent')
     * Root cause in previous version: the JS referenced an element that no longer existed in the HTML (e.g. #dbInfo).
     * This version removes those references and adds safe DOM access helpers.
     */

    // ---------------------------
    // DOM helpers
    // ---------------------------
    function mustGet(id) {
      const el = document.getElementById(id);
      if (!el) throw new Error(`Missing required element: #${id}`);
      return el;
    }

    function safeGet(id) {
      return document.getElementById(id) || null;
    }

    // ---------------------------
    // DOM handles
    // ---------------------------
    const elDrop = mustGet('dropzone');
    const elStatus = mustGet('status');
    const elTbody = mustGet('tbody');
    const elExport = mustGet('btnExport');
    const elPick = mustGet('btnPick');
    const elFileInput = mustGet('fileInput');
    const elFileMeta = mustGet('fileMeta');
    const elCountPill = mustGet('countPill');
    const elTreeView = mustGet('treeView');

    // (Diagnostics UI removed; we keep tests running quietly)
    const elDiag = safeGet('diag');
    const elTests = safeGet('tests');

    // ---------------------------
    // State
    // ---------------------------
    let currentZipName = null;
    /** @type {{instance: string, query_name: string, cypher: string, total_exec_time_ms: string}[]} */
    let currentRows = [];

    /** @type {string} */
    let currentCustomer = '';
    /** @type {Map<string,string>} */
    let currentAdvertisedByInstance = new Map();
    /** @type {object|null} */
    let currentModel = null;

    // ID counter for unique IDs
    let idCounter = 0;

    // ---------------------------
    // Settings storage
    // ---------------------------
    function saveSettings() {
      if (!currentZipName) return;
      const settings = {};
      const form = document.querySelector('.model-form');
      if (!form) return;

      // Node labels counts
      form.querySelectorAll('.model-section:first-of-type .count-slider').forEach((slider, i) => {
        settings[`node-${i}-count`] = slider.value;
      });

      // Node properties
      form.querySelectorAll('.model-section:first-of-type table tbody tr').forEach((row, i) => {
        const typeSel = row.querySelector('.type-select');
        const occSlider = row.querySelector('.occ-slider');
        const templateSel = row.querySelector('.template-select');
        const configCell = row.querySelector('.config-cell');
        if (typeSel) settings[`node-prop-${i}-type`] = typeSel.value;
        if (occSlider) settings[`node-prop-${i}-occ`] = occSlider.value;
        if (templateSel) settings[`node-prop-${i}-template`] = templateSel.value;
        const inputs = configCell ? configCell.querySelectorAll('input, select') : [];
        inputs.forEach((inp, j) => {
          settings[`node-prop-${i}-config-${j}`] = inp.value;
        });
      });

      // Relationship counts
      form.querySelectorAll('.model-section:nth-of-type(2) .count-slider').forEach((slider, i) => {
        settings[`rel-${i}-count`] = slider.value;
      });

      // Relationship source/target selects
      const relSels = form.querySelectorAll('.model-section:nth-of-type(2) .source-select, .model-section:nth-of-type(2) .target-select');
      relSels.forEach((sel, i) => {
        settings[`rel-sel-${i}`] = sel.value;
      });

      // Relationship properties
      form.querySelectorAll('.model-section:nth-of-type(2) table tbody tr').forEach((row, i) => {
        const typeSel = row.querySelector('.type-select');
        const occSlider = row.querySelector('.occ-slider');
        const templateSel = row.querySelector('.template-select');
        const configCell = row.querySelector('.config-cell');
        if (typeSel) settings[`rel-prop-${i}-type`] = typeSel.value;
        if (occSlider) settings[`rel-prop-${i}-occ`] = occSlider.value;
        if (templateSel) settings[`rel-prop-${i}-template`] = templateSel.value;
        const inputs = configCell ? configCell.querySelectorAll('input, select') : [];
        inputs.forEach((inp, j) => {
          settings[`rel-prop-${i}-config-${j}`] = inp.value;
        });
      });

      localStorage.setItem(`settings-${currentZipName}`, JSON.stringify(settings));
    }

    function loadSettings() {
      if (!currentZipName) return;
      const stored = localStorage.getItem(`settings-${currentZipName}`);
      if (!stored) return;
      const settings = JSON.parse(stored);
      const form = document.querySelector('.model-form');
      if (!form) return;

      // Apply settings
      Object.keys(settings).forEach(key => {
        const value = settings[key];
        if (key.startsWith('node-') && key.endsWith('-count')) {
          const i = parseInt(key.split('-')[1]);
          const slider = form.querySelectorAll('.model-section:first-of-type .count-slider')[i];
          if (slider) {
            slider.value = value;
            slider.dispatchEvent(new Event('input'));
          }
        } else if (key.startsWith('node-prop-')) {
          const parts = key.split('-');
          const i = parseInt(parts[2]);
          const row = form.querySelectorAll('.model-section:first-of-type table tbody tr')[i];
          if (!row) return;
          if (key.includes('-type')) {
            const sel = row.querySelector('.type-select');
            if (sel) {
              sel.value = value;
              sel.dispatchEvent(new Event('change'));
            }
          } else if (key.includes('-occ')) {
            const slider = row.querySelector('.occ-slider');
            if (slider) {
              slider.value = value;
              slider.dispatchEvent(new Event('input'));
            }
          } else if (key.includes('-template')) {
            const sel = row.querySelector('.template-select');
            if (sel) {
              sel.value = value;
              sel.dispatchEvent(new Event('change'));
            }
          } else if (key.includes('-config-')) {
            const j = parseInt(parts[4]);
            const configCell = row.querySelector('.config-cell');
            const inputs = configCell ? configCell.querySelectorAll('input, select') : [];
            if (inputs[j]) inputs[j].value = value;
          }
        } else if (key.startsWith('rel-') && key.endsWith('-count')) {
          const i = parseInt(key.split('-')[1]);
          const slider = form.querySelectorAll('.model-section:nth-of-type(2) .count-slider')[i];
          if (slider) {
            slider.value = value;
            slider.dispatchEvent(new Event('input'));
          }
        } else if (key.startsWith('rel-sel-')) {
          const i = parseInt(key.split('-')[2]);
          const sels = form.querySelectorAll('.model-section:nth-of-type(2) .source-select, .model-section:nth-of-type(2) .target-select');
          if (sels[i]) sels[i].value = value;
        } else if (key.startsWith('rel-prop-')) {
          const parts = key.split('-');
          const i = parseInt(parts[2]);
          const row = form.querySelectorAll('.model-section:nth-of-type(2) table tbody tr')[i];
          if (!row) return;
          if (key.includes('-type')) {
            const sel = row.querySelector('.type-select');
            if (sel) {
              sel.value = value;
              sel.dispatchEvent(new Event('change'));
            }
          } else if (key.includes('-occ')) {
            const slider = row.querySelector('.occ-slider');
            if (slider) {
              slider.value = value;
              slider.dispatchEvent(new Event('input'));
            }
          } else if (key.includes('-template')) {
            const sel = row.querySelector('.template-select');
            if (sel) {
              sel.value = value;
              sel.dispatchEvent(new Event('change'));
            }
          } else if (key.includes('-config-')) {
            const j = parseInt(parts[4]);
            const configCell = row.querySelector('.config-cell');
            const inputs = configCell ? configCell.querySelectorAll('input, select') : [];
            if (inputs[j]) inputs[j].value = value;
          }
        }
      });
    }

    // ---------------------------
    // Utilities
    // ---------------------------
    function escapeHtml(str) {
      return String(str)
        .replaceAll('&', '&amp;')
        .replaceAll('<', '&lt;')
        .replaceAll('>', '&gt;')
        .replaceAll('"', '&quot;')
        .replaceAll("'", '&#39;');
    }

    function setStatus(message, kind) {
      // status is required by mustGet(), but keep this defensive in case the HTML gets edited later.
      if (!elStatus) return;
      if (!message) {
        elStatus.innerHTML = '';
        return;
      }
      const cls = kind === 'good' ? 'pill good' : (kind === 'bad' ? 'pill bad' : 'pill');
      elStatus.innerHTML = `<span class="${cls}">${escapeHtml(message)}</span>`;
    }

    function renderTree(rows) {
      if (!rows.length) {
        elTreeView.innerHTML = '<div class="muted" style="padding: 8px 12px; font-size: 12px;">No data to display</div>';
        return;
      }

      // Build hierarchy: root -> instances -> queries
      const instances = Array.from(
        new Set(rows.map(r => (r.instance ?? '').trim()).filter(Boolean))
      ).sort((a, b) => {
        const an = Number(a);
        const bn = Number(b);
        const aNum = Number.isFinite(an) && String(an) === a;
        const bNum = Number.isFinite(bn) && String(bn) === b;
        if (aNum && bNum) return an - bn;
        return a.localeCompare(b);
      });

      const html = [];
      
      // Root folder
      const rootId = `root-${Date.now()}`;
      html.push(`
        <div class="tree-item expanded folder" data-toggle="${rootId}">
          <div class="tree-icon">▼</div>
          <div class="tree-name">${escapeHtml(currentZipName || 'Queries')}</div>
        </div>
        <div class="tree-children" id="${rootId}">
      `);

      // Instance folders and their queries
      for (const inst of instances) {
        const instId = `inst-${escapeHtml(inst)}-${Date.now()}`;
        const instLabel = inst || '(no instance)';
        
        html.push(`
          <div class="tree-item collapsed folder" data-toggle="${instId}">
            <div class="tree-icon">▶</div>
            <div class="tree-name">Instance #${escapeHtml(inst)}</div>
          </div>
          <div class="tree-children" id="${instId}">
        `);

        // Queries in this instance
        const instRows = rows.filter(r => (r.instance ?? '').trim() === inst);
        for (const row of instRows) {
          html.push(`
            <div class="tree-item">
              <div class="tree-icon" style="visibility: hidden;"></div>
              <div class="tree-name">${escapeHtml(row.query_name || 'Unnamed')}</div>
            </div>
          `);
        }

        html.push('</div>');
      }

      html.push('</div>');

      elTreeView.innerHTML = html.join('');

      // Add toggle listeners
      elTreeView.querySelectorAll('.tree-item.folder').forEach(item => {
        item.addEventListener('click', (e) => {
          e.stopPropagation();
          const toggleId = item.getAttribute('data-toggle');
          const childContainer = document.getElementById(toggleId);
          if (childContainer) {
            item.classList.toggle('collapsed');
            item.classList.toggle('expanded');
          }
        });
      });
    }

    function getTemplateOptions(type) {
      if (type === 'String') {
        return [
          'uuid', 'string from list', 'person name', 'city', 'country', 'IP address',
          'faker.person.firstName', 'faker.person.lastName', 'faker.person.fullName',
          'faker.address.city', 'faker.address.country', 'faker.address.streetAddress',
          'faker.internet.email', 'faker.internet.url', 'faker.internet.ip',
          'faker.company.name', 'faker.company.catchPhrase', 'faker.lorem.words',
          'faker.phone.number', 'faker.finance.accountNumber'
        ];
      } else if (type === 'Boolean') {
        return ['random', 'always TRUE', 'always FALSE'];
      } else if (type === 'DateTime') {
        return ['random datetime', 'datetime from list', 'faker.date.past', 'faker.date.future', 'faker.date.recent'];
      } else if (type === 'Point') {
        return ['random point'];
      } else {
        return [ 'distribution', 'value from list'];
      }
    }

    function renderModel(model) {
      const el = document.getElementById('modelInfo');
      if (!model) {
        el.innerHTML = 'No model data available.';
        return;
      }

      const neo4jTypes = ['String', 'Integer', 'Float', 'Boolean', 'DateTime', 'Point'];
      const nodeLabels = Object.keys(model.nodeLabels || {});

      function getConfigHtml(template) {
        if (template === 'value from list' || template === 'string from list' || template === 'datetime from list') {
          return '<input type="text" placeholder="comma-separated list">';
        } else if (template === 'distribution') {
          return '<label><output>0</output> Min: <input type="range" min="-32768" max="32767" value="0" class="min-slider"></label> <label><output>2000</output> Max: <input type="range" min="-32768" max="32767" value="2000" class="max-slider"></label> <label>Dist: <select><option>random / uniform</option><option>normal</option><option>power law</option></select></label>';
        } else if (template === 'random datetime') {
          return '<label>Min: <input type="date" value="1970-01-01"></label> <label>Max: <input type="date" value="2031-01-01"></label>';
        } else if (template === 'random point') {
          return '<label><output>-180</output> X Min: <input type="range" min="-180" max="180" value="-180" class="min-slider"></label> <label><output>180</output> X Max: <input type="range" min="-180" max="180" value="180" class="max-slider"></label> <label><output>-90</output> Y Min: <input type="range" min="-90" max="90" value="-90" class="min-slider"></label> <label><output>90</output> Y Max: <input type="range" min="-90" max="90" value="90" class="max-slider"></label>';
        }
        return '';
      }

      let html = '<form class="model-form">';

      // Node Labels
      html += '<div class="model-section"><h3>Node Labels</h3>';
      for (const [label, info] of Object.entries(model.nodeLabels || {}).sort(([a], [b]) => a.localeCompare(b))) {
        html += `<div class="model-item">
          <div class="node-row">
            <div class="node-label"><strong>${escapeHtml(label)}</strong></div>
            <div class="node-count">
              <input type="range" min="0" max="70" value="0" class="count-slider"> <output>0</output>
            </div>
          </div>
        </div>`;
        if (info.properties && info.properties.length) {
          html += '<table class="model-table"><thead><tr><th>Property name</th><th>Type</th><th>Occurrence %</th><th>Filling template</th><th>Filling config</th></tr></thead><tbody>';
          for (const prop of info.properties.sort((a, b) => a.key.localeCompare(b.key))) {
            const propType = prop.type || 'String';
            const defaultTemplate = propType === 'String' ? 'uuid' : propType === 'DateTime' ? 'random datetime' : propType === 'Point' ? 'random point' : 'distribution';
            const templateOptions = getTemplateOptions(propType);
            const configHtml = getConfigHtml(defaultTemplate);
            html += `<tr>
              <td>${escapeHtml(prop.key)}</td>
              <td><select class="type-select">${neo4jTypes.map(t => `<option value="${t}"${t === propType ? ' selected' : ''}>${t}</option>`).join('')}</select></td>
              <td><input type="range" min="0" max="100" value="100" class="occ-slider"> <output>100</output>%</td>
              <td><select class="template-select">${templateOptions.map(o => `<option value="${o}"${o === defaultTemplate ? ' selected' : ''}>${o}</option>`).join('')}</select></td>
              <td class="config-cell">${configHtml}</td>
            </tr>`;
          }
          html += '</tbody></table>';
        }
      }
      html += '</div>';

      // Relationship Types
      html += '<div class="model-section"><h3>Relationship Types</h3>';
      for (const [type, info] of Object.entries(model.relationshipTypes || {}).sort(([a], [b]) => a.localeCompare(b))) {
        const sourceOptions = (info.sourceNodeLabels && info.sourceNodeLabels.length > 0 ? info.sourceNodeLabels : nodeLabels).sort((a, b) => a.localeCompare(b));
        const targetOptions = (info.targetNodeLabels && info.targetNodeLabels.length > 0 ? info.targetNodeLabels : nodeLabels).sort((a, b) => a.localeCompare(b));
        const isSourceAll = !(info.sourceNodeLabels && info.sourceNodeLabels.length > 0);
        const isTargetAll = !(info.targetNodeLabels && info.targetNodeLabels.length > 0);
        html += `<div class="model-item">
          <div class="rel-row">
            <div class="rel-type"><strong>${escapeHtml(type)}</strong></div>
            <div class="rel-count">
              <input type="range" min="0" max="70" value="0" class="count-slider"> <output>0</output>
              <button type="button" class="set-to-source-btn" style="font-size: 11px; padding: 2px 6px; margin-left: 8px;">Set to Source</button>
              <button type="button" class="set-to-target-btn" style="font-size: 11px; padding: 2px 6px; margin-left: 4px;">Set to Target</button>
            </div>
            <div class="rel-source">
              <select class="source-select">${sourceOptions.map(l => `<option value="${l}"${l === sourceOptions[0] ? ' selected' : ''}${isSourceAll ? ' style="color: grey;"' : ''}>${l}</option>`).join('')}</select>
            </div>
            <div class="rel-target">
              <select class="target-select">${targetOptions.map(l => `<option value="${l}"${l === targetOptions[0] ? ' selected' : ''}${isTargetAll ? ' style="color: grey;"' : ''}>${l}</option>`).join('')}</select>
            </div>
          </div>
        </div>`;
        // Properties
        if (info.properties && info.properties.length) {
          html += '<table class="model-table"><thead><tr><th>Property name</th><th>Type</th><th>Occurrence %</th><th>Filling template</th><th>Filling config</th></tr></thead><tbody>';
          for (const prop of info.properties.sort((a, b) => a.key.localeCompare(b.key))) {
            const propType = prop.type || 'String';
            const defaultTemplate = propType === 'String' ? 'uuid' : propType === 'DateTime' ? 'random datetime' : propType === 'Point' ? 'random point' : 'distribution';
            const templateOptions = getTemplateOptions(propType);
            const configHtml = getConfigHtml(defaultTemplate);
            html += `<tr>
              <td>${escapeHtml(prop.key)}</td>
              <td><select class="type-select">${neo4jTypes.map(t => `<option value="${t}"${t === propType ? ' selected' : ''}>${t}</option>`).join('')}</select></td>
              <td><input type="range" min="0" max="100" value="100" class="occ-slider"> <output>100</output>%</td>
              <td><select class="template-select">${templateOptions.map(o => `<option value="${o}"${o === defaultTemplate ? ' selected' : ''}>${o}</option>`).join('')}</select></td>
              <td class="config-cell">${configHtml}</td>
            </tr>`;
          }
          html += '</tbody></table>';
        }
        // Source labels
        if (info.sourceNodeLabels && info.sourceNodeLabels.length > 1) {
          html += '<div class="model-sub"><strong>Source Node Labels:</strong><ul>';
          for (const lbl of info.sourceNodeLabels) {
            html += `<li>${escapeHtml(lbl)}</li>`;
          }
          html += '</ul></div>';
        }
        // Target labels
        if (info.targetNodeLabels && info.targetNodeLabels.length > 1) {
          html += '<div class="model-sub"><strong>Target Node Labels:</strong><ul>';
          for (const lbl of info.targetNodeLabels) {
            html += `<li>${escapeHtml(lbl)}</li>`;
          }
          html += '</ul></div>';
        }
        // Undirected labels
        if (info.undirectedNodeLabels && info.undirectedNodeLabels.length) {
          html += '<div class="model-sub"><strong>Undirected Node Labels:</strong><ul>';
          for (const lbl of info.undirectedNodeLabels) {
            html += `<li>${escapeHtml(lbl)}</li>`;
          }
          html += '</ul></div>';
        }
      }
      html += '</div>';

      html += '</form>';
      el.innerHTML = html;
      setupModelForm();
      loadSettings();
      // Add save listeners
      const form = document.querySelector('.model-form');
      if (form) {
        form.addEventListener('input', saveSettings);
        form.addEventListener('change', saveSettings);
      }
    }

    function setupModelForm() {
      function computeCount(sliderValue) {
        if (sliderValue === 0) return 0;
        return Math.round(Math.pow(10, sliderValue / 10));
      }

      // Update outputs for sliders
      document.querySelectorAll('.count-slider').forEach(inp => {
        const out = inp.nextElementSibling;
        if (out && out.tagName === 'OUTPUT') {
          out.textContent = computeCount(parseInt(inp.value));
          inp.addEventListener('input', () => out.textContent = computeCount(parseInt(inp.value)));
        }
      });

      document.querySelectorAll('.occ-slider').forEach(inp => {
        const out = inp.nextElementSibling;
        if (out && out.tagName === 'OUTPUT') {
          out.textContent = inp.value;
          inp.addEventListener('input', () => out.textContent = inp.value);
        }
      });

      document.querySelectorAll('.min-slider, .max-slider').forEach(inp => {
        const out = inp.previousElementSibling;
        if (out && out.tagName === 'OUTPUT') {
          out.textContent = inp.value;
          inp.addEventListener('input', () => out.textContent = inp.value);
        }
      });

      // Enforce min <= max for each pair
      document.querySelectorAll('.config-cell').forEach(cell => {
        const sliders = cell.querySelectorAll('.min-slider, .max-slider');
        for (let i = 0; i < sliders.length; i += 2) {
          const minSlider = sliders[i];
          const maxSlider = sliders[i + 1];
          if (minSlider && maxSlider) {
            const enforce = () => {
              const minVal = parseInt(minSlider.value);
              const maxVal = parseInt(maxSlider.value);
              if (minVal > maxVal) {
                maxSlider.value = minVal;
                maxSlider.previousElementSibling.textContent = minVal;
              }
            };
            minSlider.addEventListener('input', enforce);
            maxSlider.addEventListener('input', enforce);
          }
        }
      });

      // Handle type select changes
      document.querySelectorAll('.type-select').forEach(sel => {
        sel.addEventListener('change', (e) => {
          const row = e.target.closest('tr');
          const templateSel = row.querySelector('.template-select');
          const type = e.target.value;
          const options = getTemplateOptions(type);
          templateSel.innerHTML = options.map(o => `<option value="${o}">${o}</option>`).join('');
          templateSel.dispatchEvent(new Event('change'));
        });
      });

      // Handle template select changes
      document.querySelectorAll('.template-select').forEach(sel => {
        sel.addEventListener('change', (e) => {
          const row = e.target.closest('tr');
          const configCell = row.querySelector('.config-cell');
          const template = e.target.value;
          let html = '';
          if (template === 'value from list' || template === 'string from list' || template === 'datetime from list') {
            html = '<input type="text" placeholder="comma-separated list">';
          } else if (template === 'distribution') {
            html = '<label><output>0</output> Min: <input type="range" min="-32768" max="32767" value="0" class="min-slider"></label> <label><output>2000</output> Max: <input type="range" min="-32768" max="32767" value="2000" class="max-slider"></label> <label>Dist: <select><option>random / uniform</option><option>normal</option><option>power law</option></select></label>';
          } else if (template === 'random datetime') {
            html = '<label>Min: <input type="date" value="1970-01-01"></label> <label>Max: <input type="date" value="2031-01-01"></label>';
          } else if (template === 'random point') {
            html = '<label><output>-180</output> X Min: <input type="range" min="-180" max="180" value="-180" class="min-slider"></label> <label><output>180</output> X Max: <input type="range" min="-180" max="180" value="180" class="max-slider"></label> <label><output>-90</output> Y Min: <input type="range" min="-90" max="90" value="-90" class="min-slider"></label> <label><output>90</output> Y Max: <input type="range" min="-90" max="90" value="90" class="max-slider"></label>';
          }
          configCell.innerHTML = html;
          // Setup new sliders
          const sliders = configCell.querySelectorAll('.min-slider, .max-slider');
          for (let i = 0; i < sliders.length; i += 2) {
            const minS = sliders[i];
            const maxS = sliders[i + 1];
            if (minS) {
              const out = minS.previousElementSibling;
              if (out && out.tagName === 'OUTPUT') {
                out.textContent = minS.value;
                minS.addEventListener('input', () => out.textContent = minS.value);
              }
            }
            if (maxS) {
              const out = maxS.previousElementSibling;
              if (out && out.tagName === 'OUTPUT') {
                out.textContent = maxS.value;
                maxS.addEventListener('input', () => out.textContent = maxS.value);
              }
            }
            if (minS && maxS) {
              const enforce = () => {
                const minVal = parseInt(minS.value);
                const maxVal = parseInt(maxS.value);
                if (minVal > maxVal) {
                  maxS.value = minVal;
                  maxS.nextElementSibling.textContent = minVal;
                }
              };
              minS.addEventListener('input', enforce);
              maxS.addEventListener('input', enforce);
            }
          }
        });
      });

      // Handle set to source/target buttons
      document.querySelectorAll('.set-to-source-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
          const item = e.target.closest('.model-item');
          const sourceSelect = item.querySelector('.source-select');
          const countSlider = item.querySelector('.count-slider');
          if (sourceSelect && countSlider) {
            const sourceLabel = sourceSelect.value;
            // Find the node label count slider
            const nodeSections = document.querySelectorAll('.model-section');
            for (const section of nodeSections) {
              if (section.querySelector('h3')?.textContent === 'Node Labels') {
                const nodeItems = section.querySelectorAll('.model-item');
                for (const nodeItem of nodeItems) {
                  const label = nodeItem.querySelector('strong')?.textContent.trim();
                  if (label === sourceLabel) {
                    const nodeCountSlider = nodeItem.querySelector('.count-slider');
                    if (nodeCountSlider) {
                      countSlider.value = nodeCountSlider.value;
                      countSlider.dispatchEvent(new Event('input'));
                      break;
                    }
                  }
                }
                break;
              }
            }
          }
        });
      });

      document.querySelectorAll('.set-to-target-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
          const item = e.target.closest('.model-item');
          const targetSelect = item.querySelector('.target-select');
          const countSlider = item.querySelector('.count-slider');
          if (targetSelect && countSlider) {
            const targetLabel = targetSelect.value;
            // Find the node label count slider
            const nodeSections = document.querySelectorAll('.model-section');
            for (const section of nodeSections) {
              if (section.querySelector('h3')?.textContent === 'Node Labels') {
                const nodeItems = section.querySelectorAll('.model-item');
                for (const nodeItem of nodeItems) {
                  const label = nodeItem.querySelector('strong')?.textContent.trim();
                  if (label === targetLabel) {
                    const nodeCountSlider = nodeItem.querySelector('.count-slider');
                    if (nodeCountSlider) {
                      countSlider.value = nodeCountSlider.value;
                      countSlider.dispatchEvent(new Event('input'));
                      break;
                    }
                  }
                }
                break;
              }
            }
          }
        });
      });
    }

    function collectModelConfig() {
      if (!currentModel) return null;
      
      const config = {
        nodeLabels: {},
        relationshipTypes: {}
      };
      
      // Collect node label configs
      document.querySelectorAll('.model-section h3').forEach(h3 => {
        if (h3.textContent === 'Node Labels') {
          const section = h3.parentElement;
          section.querySelectorAll('.model-item').forEach(item => {
            const label = item.querySelector('strong').textContent.trim();
            const countSlider = item.querySelector('.count-slider');
            const count = countSlider ? parseInt(countSlider.value) : 0;
            if (count > 0) {
              const properties = [];
              const table = item.nextElementSibling;
              if (table && table.tagName === 'TABLE' && table.classList.contains('model-table')) {
                table.querySelectorAll('tbody tr').forEach(row => {
                  const cells = row.querySelectorAll('td');
                  if (cells.length >= 5) {
                    const propName = cells[0].textContent.trim();
                    const typeSelect = cells[1].querySelector('.type-select');
                    const occSlider = cells[2].querySelector('.occ-slider');
                    const templateSelect = cells[3].querySelector('.template-select');
                    const configCell = cells[4];
                    
                    const propConfig = {
                      key: propName,
                      type: typeSelect ? typeSelect.value : 'String',
                      occurrence: occSlider ? parseInt(occSlider.value) : 100,
                      template: templateSelect ? templateSelect.value : 'uuid',
                      config: {}
                    };
                    
                    // Collect config values based on template
                    if (propConfig.template === 'value from list' || propConfig.template === 'string from list' || propConfig.template === 'datetime from list') {
                      const input = configCell.querySelector('input[type="text"]');
                      propConfig.config.list = input ? input.value.split(',').map(s => s.trim()) : [];
                    } else if (propConfig.template === 'distribution') {
                      const minSlider = configCell.querySelector('.min-slider');
                      const maxSlider = configCell.querySelector('.max-slider');
                      const distSelect = configCell.querySelector('select');
                      propConfig.config.min = minSlider ? parseInt(minSlider.value) : -32768;
                      propConfig.config.max = maxSlider ? parseInt(maxSlider.value) : 32767;
                      propConfig.config.distribution = distSelect ? distSelect.value : 'random / uniform';
                    } else if (propConfig.template === 'random datetime') {
                      const minInput = configCell.querySelector('input[type="date"]:first-of-type');
                      const maxInput = configCell.querySelector('input[type="date"]:last-of-type');
                      propConfig.config.minDate = minInput ? minInput.value : '1970-01-01';
                      propConfig.config.maxDate = maxInput ? maxInput.value : '2031-01-01';
                    } else if (propConfig.template === 'random point') {
                      const sliders = configCell.querySelectorAll('.min-slider, .max-slider');
                      propConfig.config.xMin = sliders[0] ? parseInt(sliders[0].value) : -180;
                      propConfig.config.xMax = sliders[1] ? parseInt(sliders[1].value) : 180;
                      propConfig.config.yMin = sliders[2] ? parseInt(sliders[2].value) : -90;
                      propConfig.config.yMax = sliders[3] ? parseInt(sliders[3].value) : 90;
                    }
                    
                    properties.push(propConfig);
                  }
                });
              }
              
              config.nodeLabels[label] = { 
                count: Math.round(Math.pow(10, count / 10)),
                properties: properties
              };
            }
          });
        } else if (h3.textContent === 'Relationship Types') {
          const section = h3.parentElement;
          section.querySelectorAll('.model-item').forEach(item => {
            const type = item.querySelector('strong').textContent.trim();
            const countSlider = item.querySelector('.count-slider');
            const count = countSlider ? parseInt(countSlider.value) : 0;
            const sourceSelect = item.querySelector('.source-select');
            const targetSelect = item.querySelector('.target-select');
            const source = sourceSelect ? sourceSelect.value : '';
            const target = targetSelect ? targetSelect.value : '';
            if (count > 0 && source && target) {
              const properties = [];
              const table = item.nextElementSibling;
              if (table && table.tagName === 'TABLE' && table.classList.contains('model-table')) {
                table.querySelectorAll('tbody tr').forEach(row => {
                  const cells = row.querySelectorAll('td');
                  if (cells.length >= 5) {
                    const propName = cells[0].textContent.trim();
                    const typeSelect = cells[1].querySelector('.type-select');
                    const occSlider = cells[2].querySelector('.occ-slider');
                    const templateSelect = cells[3].querySelector('.template-select');
                    const configCell = cells[4];
                    
                    const propConfig = {
                      key: propName,
                      type: typeSelect ? typeSelect.value : 'String',
                      occurrence: occSlider ? parseInt(occSlider.value) : 100,
                      template: templateSelect ? templateSelect.value : 'uuid',
                      config: {}
                    };
                    
                    // Collect config values based on template
                    if (propConfig.template === 'value from list' || propConfig.template === 'string from list' || propConfig.template === 'datetime from list') {
                      const input = configCell.querySelector('input[type="text"]');
                      propConfig.config.list = input ? input.value.split(',').map(s => s.trim()) : [];
                    } else if (propConfig.template === 'distribution') {
                      const minSlider = configCell.querySelector('.min-slider');
                      const maxSlider = configCell.querySelector('.max-slider');
                      const distSelect = configCell.querySelector('select');
                      propConfig.config.min = minSlider ? parseInt(minSlider.value) : -32768;
                      propConfig.config.max = maxSlider ? parseInt(maxSlider.value) : 32767;
                      propConfig.config.distribution = distSelect ? distSelect.value : 'random / uniform';
                    } else if (propConfig.template === 'random datetime') {
                      const minInput = configCell.querySelector('input[type="date"]:first-of-type');
                      const maxInput = configCell.querySelector('input[type="date"]:last-of-type');
                      propConfig.config.minDate = minInput ? minInput.value : '1970-01-01';
                      propConfig.config.maxDate = maxInput ? maxInput.value : '2031-01-01';
                    } else if (propConfig.template === 'random point') {
                      const sliders = configCell.querySelectorAll('.min-slider, .max-slider');
                      propConfig.config.xMin = sliders[0] ? parseInt(sliders[0].value) : -180;
                      propConfig.config.xMax = sliders[1] ? parseInt(sliders[1].value) : 180;
                      propConfig.config.yMin = sliders[2] ? parseInt(sliders[2].value) : -90;
                      propConfig.config.yMax = sliders[3] ? parseInt(sliders[3].value) : 90;
                    }
                    
                    properties.push(propConfig);
                  }
                });
              }
              
              config.relationshipTypes[type] = {
                count: Math.round(Math.pow(10, count / 10)),
                source: source,
                target: target,
                properties: properties
              };
            }
          });
        }
      });
      
      return config;
    }

    async function generateSyntheticDataCypher(config) {
      if (!config) return '';
      
      // Ensure Faker is loaded
      let faker = null;
      try {
        faker = await ensureFaker();
      } catch (e) {
        console.warn('Faker not available, using fallback values');
      }
      
      const statements = [];
      
      function generateValueExpression(propConfig) {
        const { type, template, config: propCfg } = propConfig;
        
        switch (template) {
          case 'uuid':
            return 'randomUUID()';
          case 'person name':
            return '"Person_" + toString(toInteger(rand() * 10000))';
          case 'city':
            return '"City_" + toString(toInteger(rand() * 1000))';
          case 'country':
            return '"Country_" + toString(toInteger(rand() * 200))';
          case 'IP address':
            return '"192.168." + toString(toInteger(rand() * 255)) + "." + toString(toInteger(rand() * 255))';
          case 'string from list':
            const list = propCfg.list || ['value1', 'value2', 'value3'];
            return `["${list.join('","')}"] [toInteger(rand() * ${list.length})]`;
          case 'faker.person.firstName':
            if (faker) {
              const names = Array.from({length: 20}, () => faker.name.firstName());
              return `["${names.join('","')}"] [toInteger(rand() * 20)]`;
            }
            return `["John","Jane","Michael","Sarah","David","Lisa","Robert","Maria","James","Anna","William","Emma","Christopher","Olivia","Daniel","Sophia","Matthew","Isabella","Anthony","Ava"][toInteger(rand() * 20)]`;
          case 'faker.person.lastName':
            if (faker) {
              const names = Array.from({length: 20}, () => faker.name.lastName());
              return `["${names.join('","')}"] [toInteger(rand() * 20)]`;
            }
            return `["Smith","Johnson","Williams","Brown","Jones","Garcia","Miller","Davis","Rodriguez","Martinez","Hernandez","Lopez","Gonzalez","Wilson","Anderson","Thomas","Taylor","Moore","Jackson","Martin"][toInteger(rand() * 20)]`;
          case 'faker.person.fullName':
            if (faker) {
              const names = Array.from({length: 10}, () => faker.name.findName());
              return `["${names.join('","')}"] [toInteger(rand() * 10)]`;
            }
            return `["John Smith","Jane Johnson","Michael Williams","Sarah Brown","David Jones","Lisa Garcia","Robert Miller","Maria Davis","James Rodriguez","Anna Martinez"][toInteger(rand() * 10)]`;
          case 'faker.address.city':
            if (faker) {
              const cities = Array.from({length: 20}, () => faker.address.city());
              return `["${cities.join('","')}"] [toInteger(rand() * 20)]`;
            }
            return `["New York","Los Angeles","Chicago","Houston","Phoenix","Philadelphia","San Antonio","San Diego","Dallas","San Jose","Austin","Jacksonville","Fort Worth","Columbus","Charlotte","San Francisco","Indianapolis","Seattle","Denver","Boston"][toInteger(rand() * 20)]`;
          case 'faker.address.country':
            if (faker) {
              const countries = Array.from({length: 20}, () => faker.address.country());
              return `["${countries.join('","')}"] [toInteger(rand() * 20)]`;
            }
            return `["United States","Canada","United Kingdom","Germany","France","Italy","Spain","Netherlands","Australia","Japan","China","India","Brazil","Mexico","Russia","South Korea","Sweden","Norway","Denmark","Finland"][toInteger(rand() * 20)]`;
          case 'faker.address.streetAddress':
            if (faker) {
              const addresses = Array.from({length: 10}, () => faker.address.streetAddress());
              return `["${addresses.join('","')}"] [toInteger(rand() * 10)]`;
            }
            return `"${toInteger(rand() * 9999) + 1} " + ["Main St","Oak Ave","Pine Rd","Elm St","Maple Dr","Cedar Ln","Birch Blvd","Spruce Way","Willow Ct","Ash Pl"][toInteger(rand() * 10)]`;
          case 'faker.internet.email':
            if (faker) {
              const emails = Array.from({length: 10}, () => faker.internet.email());
              return `["${emails.join('","')}"] [toInteger(rand() * 10)]`;
            }
            return `["john","jane","mike","sarah","david","lisa","bob","maria","jim","anna"][toInteger(rand() * 10)] + "." + ["smith","johnson","williams","brown","jones"][toInteger(rand() * 5)] + "@" + ["gmail.com","yahoo.com","hotmail.com","outlook.com","example.com"][toInteger(rand() * 5)]`;
          case 'faker.internet.url':
            if (faker) {
              const urls = Array.from({length: 10}, () => faker.internet.url());
              return `["${urls.join('","')}"] [toInteger(rand() * 10)]`;
            }
            return `"https://" + ["google","facebook","twitter","amazon","microsoft","apple","netflix","spotify","github","stackoverflow"][toInteger(rand() * 10)] + ".com"`;
          case 'faker.internet.ip':
            if (faker) {
              const ips = Array.from({length: 10}, () => faker.internet.ip());
              return `["${ips.join('","')}"] [toInteger(rand() * 10)]`;
            }
            return `"192.168." + toString(toInteger(rand() * 255)) + "." + toString(toInteger(rand() * 255))`;
          case 'faker.company.name':
            if (faker) {
              const names = Array.from({length: 10}, () => faker.company.companyName());
              return `["${names.join('","')}"] [toInteger(rand() * 10)]`;
            }
            return `["Acme Corp","Tech Solutions","Global Industries","Innovative Systems","Digital Dynamics","Future Enterprises","Smart Technologies","Advanced Analytics","Cloud Services","Data Insights"][toInteger(rand() * 10)]`;
          case 'faker.company.catchPhrase':
            if (faker) {
              const phrases = Array.from({length: 10}, () => faker.company.catchPhrase());
              return `["${phrases.join('","')}"] [toInteger(rand() * 10)]`;
            }
            return `["Revolutionizing","Transforming","Empowering","Accelerating","Optimizing","Streamlining","Enhancing","Maximizing","Leveraging","Driving"][toInteger(rand() * 10)] + " " + ["business","technology","innovation","solutions","services","platforms","systems","experiences","processes","growth"][toInteger(rand() * 10)]`;
          case 'faker.lorem.words':
            if (faker) {
              const words = Array.from({length: 10}, () => faker.lorem.words(2));
              return `["${words.join('","')}"] [toInteger(rand() * 10)]`;
            }
            return `["lorem","ipsum","dolor","sit","amet","consectetur","adipiscing","elit","sed","do"][toInteger(rand() * 10)] + " " + ["eiusmod","tempor","incididunt","ut","labore","et","dolore","magna","aliqua","ut"][toInteger(rand() * 10)]`;
          case 'faker.phone.number':
            if (faker) {
              const phones = Array.from({length: 10}, () => faker.phone.phoneNumber());
              return `["${phones.join('","')}"] [toInteger(rand() * 10)]`;
            }
            return `"(" + toString(200 + toInteger(rand() * 800)) + ") " + toString(200 + toInteger(rand() * 800)) + "-" + toString(1000 + toInteger(rand() * 9000))`;
          case 'faker.finance.accountNumber':
            if (faker) {
              const accounts = Array.from({length: 10}, () => faker.finance.account());
              return `["${accounts.join('","')}"] [toInteger(rand() * 10)]`;
            }
            return `toString(100000000 + toInteger(rand() * 900000000))`;
          case 'faker.date.past':
            return `datetime() - duration({days: toInteger(rand() * 365 * 10)})`;
          case 'faker.date.future':
            return `datetime() + duration({days: toInteger(rand() * 365 * 10)})`;
          case 'faker.date.recent':
            return `datetime() - duration({hours: toInteger(rand() * 24 * 7)})`;
          case 'always TRUE':
            return 'true';
          case 'always FALSE':
            return 'false';
          case 'random':
            return 'rand() > 0.5';
          case 'random datetime':
            const minDate = propCfg.minDate || '1970-01-01';
            const maxDate = propCfg.maxDate || '2031-01-01';
            return `datetime("${minDate}T00:00:00Z") + duration({days: toInteger(rand() * 365 * 50)})`;
          case 'datetime from list':
            const dtList = propCfg.list || ['2020-01-01T00:00:00Z', '2021-01-01T00:00:00Z'];
            return `datetime(["${dtList.join('","')}"] [toInteger(rand() * ${dtList.length})])`;
          case 'random point':
            const xMin = propCfg.xMin || -180;
            const xMax = propCfg.xMax || 180;
            const yMin = propCfg.yMin || -90;
            const yMax = propCfg.yMax || 90;
            return `point({longitude: ${xMin} + rand() * (${xMax} - ${xMin}), latitude: ${yMin} + rand() * (${yMax} - ${yMin})})`;
          case 'value from list':
            const valList = propCfg.list || [1, 2, 3];
            return `[${valList.join(',')}] [toInteger(rand() * ${valList.length})]`;
          case 'distribution':
            const min = propCfg.min || -32768;
            const max = propCfg.max || 32767;
            const dist = propCfg.distribution || 'random / uniform';
            if (dist === 'normal') {
              // Simple approximation of normal distribution
              return `toInteger(${min} + (${max} - ${min}) * (rand() + rand() + rand() + rand() + rand() + rand() - 3) / 3)`;
            } else if (dist === 'power law') {
              // Simple power law approximation
              return `toInteger(${min} + (${max} - ${min}) * pow(rand(), 2))`;
            } else {
              return `toInteger(${min} + rand() * (${max} - ${min}))`;
            }
          default:
            // Fallback based on type
            switch (type) {
              case 'Integer': return `toInteger(${propCfg.min || -32768} + rand() * (${propCfg.max || 32767} - ${propCfg.min || -32768}))`;
              case 'Float': return `${propCfg.min || -32768} + rand() * (${propCfg.max || 32767} - ${propCfg.min || -32768})`;
              case 'Boolean': return 'rand() > 0.5';
              case 'DateTime': return 'datetime()';
              case 'Point': return 'point({longitude: rand() * 360 - 180, latitude: rand() * 180 - 90})';
              default: return `"${template}_value"`;
            }
        }
      }
      
      // Generate node creation statements
      for (const [label, info] of Object.entries(config.nodeLabels)) {
        const count = info.count;
        if (count > 0) {
          const props = info.properties || [];
          let createStmt = `CREATE (n:${label})`;
          if (props.length > 0) {
            const setAssignments = props.map(p => {
              const value = generateValueExpression(p);
              return `n.${p.key} = ${value}`;
            });
            createStmt += `\n\t\tSET ${setAssignments.join(', ')}`;
          }
          
          const batched = `UNWIND range(1, ${count}) AS i\nCALL {\n\t\t${createStmt}\n} IN CONCURRENT TRANSACTIONS OF 1000 ROWS`;
          statements.push(batched);
        }
      }
      
      // Generate relationship creation statements
      for (const [type, info] of Object.entries(config.relationshipTypes)) {
        const count = info.count;
        const sourceLabel = info.source;
        const targetLabel = info.target;
        if (count > 0 && sourceLabel && targetLabel) {
          const props = info.properties || [];
          let createStmt = `MATCH (s:${sourceLabel}), (t:${targetLabel})\n\tWITH s, t ORDER BY rand() LIMIT 1\n\tCREATE (s)-[r:${type}]->(t)`;
          if (props.length > 0) {
            const setAssignments = props.map(p => {
              const value = generateValueExpression(p);
              return `r.${p.key} = ${value}`;
            });
            createStmt += `\n\tSET ${setAssignments.join(', ')}`;
          }
          
          const batched = `UNWIND range(1, ${count}) AS i\nCALL {\n\t${createStmt}\n} IN TRANSACTIONS OF 1000 ROWS`;
          statements.push(batched);
        }
      }
      
      return statements.join(';\n\n');
    }

    function toSafeString(x) {
      if (x === null || x === undefined) return '';
      return String(x);
    }

    function setRows(rows) {
      currentRows = rows;
      elExport.disabled = rows.length === 0 || !currentZipName;
      elCountPill.textContent = `${rows.length} row${rows.length === 1 ? '' : 's'}`;

      if (!rows.length) {
        elTbody.innerHTML = `<tr><td colspan="4" class="muted">No rows found in most_costly_queries.</td></tr>`;
        renderTree(rows);
        return;
      }

      const html = rows.map(r => {
        return `
          <tr>
            <td>${escapeHtml(r.instance ?? '')}</td>
            <td>${escapeHtml(r.query_name ?? '')}</td>
            <td class="mono">${escapeHtml(r.cypher ?? '')}</td>
            <td class="right">${escapeHtml(r.total_exec_time_ms ?? '')}</td>
          </tr>
        `;
      }).join('');
      elTbody.innerHTML = html;

      renderTree(rows);
    }

    function makeId() {
      if (window.crypto?.randomUUID) return crypto.randomUUID();
      // Fallback: generate a UUID-like string that's highly unlikely to collide
      const timestamp = Date.now().toString(36);
      const random1 = Math.random().toString(36).substring(2);
      const random2 = Math.random().toString(36).substring(2);
      return `${timestamp}-${random1}-${random2}`;
    }

    function csvEscape(value) {
      const s = value === null || value === undefined ? '' : String(value);
      if (/[\n\r,\"]/g.test(s)) {
        return '"' + s.replaceAll('"', '""') + '"';
      }
      return s;
    }

    function buildExportCsv(zipName, rows, opts) {
      const header = ['name','description','query','id','parentId','isFolder'];
      const rootId = makeId();

      const customer = (opts?.customer ?? '').trim();
      /** @type {Map<string,string>} */
      const advertisedByInstance = opts?.advertisedByInstance instanceof Map ? opts.advertisedByInstance : new Map();
      const syntheticCypher = opts?.syntheticCypher ?? '';

      const instances = Array.from(
        new Set(rows.map(r => (r.instance ?? '').trim()).filter(Boolean))
      ).sort((a,b) => {
        const an = Number(a);
        const bn = Number(b);
        const aNum = Number.isFinite(an) && String(an) === a;
        const bNum = Number.isFinite(bn) && String(bn) === b;
        if (aNum && bNum) return an - bn;
        return a.localeCompare(b);
      });

      /** @type {Map<string,string>} */
      const instanceIdByValue = new Map();
      /** @type {string[][]} */
      const lines = [];

      // Root line: description from global_vars customer
      root_name = `${customer} - ${zipName || 'zip'}`;
      lines.push([root_name, customer, '', rootId, '', 'true']);

      // Synthetic Data folder and query (under root)
      if (syntheticCypher) {
        const syntheticFolderId = makeId();
        lines.push(['Synthetic Data Creation', '', syntheticCypher, makeId(), rootId, 'false']);
      }

      // Instance folder lines
      for (const inst of instances) {
        const instId = makeId();
        instanceIdByValue.set(inst, instId);

        // Description: advertisedAddress
        const descr = (advertisedByInstance.get(inst) ?? '').trim();

        // Name: "Instance #<instance+1>" when instance is numeric (0 -> Instance #1)
        const n = parseInt(inst, 10);
        const displayName =
          Number.isFinite(n) && String(n) === inst
            ? `Instance #${n + 1} [${descr || 'no advertised address'}]`
            : `Instance #${instanceIdByValue.size}`;



        lines.push([displayName, descr, '', instId, rootId, 'true']);
      }

      // Helpers for parameter companion lines
      function extractCypherParams(cypher) {
        const text = String(cypher ?? '');
        // Best-effort: find Cypher params like $varName (doesn't parse strings/comments)
        const matches = text.match(/\$[A-Za-z_][A-Za-z0-9_]*/g) || [];
        const uniq = [];
        const seen = new Set();
        for (const m of matches) {
          const name = m.slice(1);
          if (!seen.has(name)) {
            seen.add(name);
            uniq.push(name);
          }
        }
        return uniq;
      }

      function guessedParamValueLiteral(name) {
        const n = String(name).toLowerCase();
        if (n.includes('id') || n.endsWith('ids') || n.endsWith('_id')) return '1';
        if (n.includes('count') || n.includes('limit') || n.includes('skip') || n.includes('size')) return '10';
        if (n.includes('date') || n.includes('time')) return '"2026-01-01"';
        if (n.includes('name') || n.includes('type') || n.includes('label') || n.includes('key')) return '"example"';
        if (n.includes('enabled') || n.startsWith('is') || n.startsWith('has')) return 'true';
        return '"value"';
      }

      function buildParamQuery(paramNames) {
        const parts = paramNames.map(p => `${p}: ${guessedParamValueLiteral(p)}`);
        return `:param { ${parts.join(', ')} }`;
      }

      // Row lines
      for (const r of rows) {
        const inst = (r.instance ?? '').trim();
        const parentId = instanceIdByValue.get(inst) || rootId;

        // Companion parameters line (if query contains $params)
        const params = extractCypherParams(r.cypher ?? '');
        if (params.length) {
          lines.push([
            `${r.query_name ?? ''} set parameters`,
            '',
            buildParamQuery(params),
            makeId(),
            parentId,
            'false'
          ]);
        }
        // Main query line
        lines.push([
          r.query_name ?? '',
          '',
          r.cypher ?? '',
          makeId(),
          parentId,
          'false'
        ]);
      }


      const csv = [
        header.map(csvEscape).join(','),
        ...lines.map(line => line.map(csvEscape).join(','))
      ].join('\n');

      return { csv, rootId };
    }


    function downloadText(filename, text) {
      const blob = new Blob([text], { type: 'text/csv;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    // ---------------------------
    // Script loader with fallbacks
    // ---------------------------
    function loadScript(url) {
      return new Promise((resolve, reject) => {
        const s = document.createElement('script');
        s.src = url;
        s.async = true;
        s.onload = () => resolve(url);
        s.onerror = () => reject(new Error(`Failed to load script: ${url}`));
        document.head.appendChild(s);
      });
    }

    async function ensureJSZip() {
      if (window.JSZip) return window.JSZip;
      const candidates = [
        'https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js',
        'https://unpkg.com/jszip@3.10.1/dist/jszip.min.js',
        'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js'
      ];
      let lastErr = null;
      for (const url of candidates) {
        try {
          await loadScript(url);
          if (window.JSZip) return window.JSZip;
        } catch (e) {
          lastErr = e;
        }
      }
      throw lastErr || new Error('JSZip did not load.');
    }

    async function ensureSqlJs() {
      if (window.initSqlJs) return window.initSqlJs;
      const candidates = [
        'https://sql.js.org/dist/sql-wasm.js',
        'https://cdn.jsdelivr.net/npm/sql.js@1.11.0/dist/sql-wasm.js',
        'https://unpkg.com/sql.js@1.11.0/dist/sql-wasm.js'
      ];
      let lastErr = null;
      for (const url of candidates) {
        try {
          await loadScript(url);
          if (window.initSqlJs) return window.initSqlJs;
        } catch (e) {
          lastErr = e;
        }
      }
      throw lastErr || new Error('sql.js did not load.');
    }

    async function ensureFaker() {
      if (window.faker) return window.faker;
      const candidates = [
        'https://cdn.jsdelivr.net/npm/faker@5.5.3/dist/faker.min.js',
        'https://cdnjs.cloudflare.com/ajax/libs/Faker/3.1.0/faker.min.js',
        'https://unpkg.com/faker@5.5.3/dist/faker.min.js'
      ];
      let lastErr = null;
      for (const url of candidates) {
        try {
          await loadScript(url);
          if (window.faker) return window.faker;
        } catch (e) {
          lastErr = e;
        }
      }
      throw lastErr || new Error('Faker did not load.');
    }

    async function initSqlJsOnce() {
      if (window.__sqljs) return window.__sqljs;
      const init = await ensureSqlJs();
      const SQL = await init({
        locateFile: (file) => `https://sql.js.org/dist/${file}`
      });
      window.__sqljs = SQL;
      return SQL;
    }

    async function ensureLibrariesForUserAction() {
      const results = [];
      await ensureJSZip();
      results.push('JSZip: ok');
      await ensureSqlJs();
      results.push('sql.js: ok');
      await ensureFaker();
      results.push('Faker: ok');
      if (elDiag) elDiag.textContent = results.join(' · ');
    }

    // ---------------------------
    // Core: handle zip
    // ---------------------------
    async function handleZipFile(file) {
      try {
        setStatus('Loading…', '');
        setRows([]);

        currentZipName = file.name;
        currentCustomer = '';
        currentAdvertisedByInstance = new Map();
        currentModel = null;

        elFileMeta.textContent = `Loaded: ${file.name} (${(file.size/1024/1024).toFixed(2)} MB)`;

        await ensureLibrariesForUserAction();

        const zipBuf = await file.arrayBuffer();
        const zip = await window.JSZip.loadAsync(zipBuf);

        // Find hc.db (supports nested paths)
        let dbEntry = null;
        zip.forEach((relativePath, entry) => {
          const p = (relativePath || '').toLowerCase();
          if (!dbEntry && entry && !entry.dir && (p === 'hc.db' || p.endsWith('/hc.db'))) {
            dbEntry = entry;
          }
        });

        if (!dbEntry) {
          setStatus('Could not find hc.db inside the zip.', 'bad');
          return;
        }

        const dbBytes = new Uint8Array(await dbEntry.async('arraybuffer'));
        const SQL = await initSqlJsOnce();
        const db = new SQL.Database(dbBytes);

        const query = `
          SELECT instance, query_name, cypher, total_exec_time_ms
          FROM most_costly_queries
          ORDER BY instance ASC, query_name ASC
        `;

        const res = db.exec(query);
        const rows = [];

        if (res && res.length && res[0].values) {
          const cols = res[0].columns;
          const idx = {
            instance: cols.indexOf('instance'),
            query_name: cols.indexOf('query_name'),
            cypher: cols.indexOf('cypher'),
            total_exec_time_ms: cols.indexOf('total_exec_time_ms'),
          };

          for (const v of res[0].values) {
            rows.push({
              instance: idx.instance >= 0 ? String(v[idx.instance] ?? '') : '',
              query_name: idx.query_name >= 0 ? String(v[idx.query_name] ?? '') : '',
              cypher: idx.cypher >= 0 ? String(v[idx.cypher] ?? '') : '',
              total_exec_time_ms: idx.total_exec_time_ms >= 0 ? toSafeString(v[idx.total_exec_time_ms]) : ''
            });
          }
        }

        // Ensure deterministic ordering even if the DB collation differs.
        rows.sort((a, b) => {
          const ai = (a.instance ?? '').localeCompare(b.instance ?? '');
          if (ai !== 0) return ai;
          return (a.query_name ?? '').localeCompare(b.query_name ?? '');
        });

        // Enrich export metadata
        try {
          // Root description: customer
          const custRes = db.exec("SELECT value FROM global_vars WHERE key='customer' LIMIT 1");
          if (custRes?.length && custRes[0].values?.length) {
            currentCustomer = toSafeString(custRes[0].values[0][0]).trim();
          }

          // Instance descriptions: advertisedAddress per instance
          const instSet = Array.from(new Set(rows.map(r => (r.instance ?? '').trim()).filter(Boolean)));

          const stmt = db.prepare("SELECT value FROM instance_vars WHERE key='advertisedAddress' AND instance = ? LIMIT 1");
          try {
            for (const inst of instSet) {
              stmt.bind([inst]);
              let val = '';
              if (stmt.step()) {
                const obj = stmt.getAsObject();
                val = toSafeString(obj.value ?? '').trim();
              }
              stmt.reset();
              if (val) currentAdvertisedByInstance.set(inst, val);
            }
          } finally {
            stmt.free();
          }
        } catch (e) {
          // Non-fatal: export will simply omit descriptions.
          console.warn('Metadata enrichment failed:', e);
        }

        // Query model_json
        try {
          const modelRes = db.exec("SELECT value FROM global_vars WHERE key='model_json' LIMIT 1");
          if (modelRes?.length && modelRes[0].values?.length) {
            const jsonStr = toSafeString(modelRes[0].values[0][0]);
            currentModel = JSON.parse(jsonStr);
          } else {
            currentModel = null;
          }
        } catch (e) {
          console.warn('Model JSON query failed:', e);
          currentModel = null;
        }

        db.close();

        setRows(rows);
        renderModel(currentModel);

        setStatus('Loaded hc.db and queried most_costly_queries.', 'good');
      } catch (err) {
        console.error(err);
        const msg = err?.message ? String(err.message) : String(err);
        setStatus(`Error: ${msg}`, 'bad');
      }
    }

    // ---------------------------
    // Events
    // ---------------------------
    elPick.addEventListener('click', () => elFileInput.click());

    elFileInput.addEventListener('change', (e) => {
      const f = e.target.files && e.target.files[0];
      if (f) handleZipFile(f);
      e.target.value = '';
    });

    elExport.addEventListener('click', async () => {
      if (!currentZipName || !currentRows.length) return;
      
      const modelConfig = collectModelConfig();
      const syntheticCypher = modelConfig ? await generateSyntheticDataCypher(modelConfig) : '';
      
      const { csv } = buildExportCsv(currentZipName, currentRows, {
        customer: currentCustomer,
        advertisedByInstance: currentAdvertisedByInstance,
        syntheticCypher: syntheticCypher
      });

      const outName = `${currentZipName.replace(/\.zip$/i,'') || 'export'}.csv`;
      downloadText(outName, csv);
    });

    ['dragenter', 'dragover'].forEach(evt => {
      elDrop.addEventListener(evt, (e) => {
        e.preventDefault();
        e.stopPropagation();
        elDrop.classList.add('dragover');
      });
    });

    ['dragleave', 'drop'].forEach(evt => {
      elDrop.addEventListener(evt, (e) => {
        e.preventDefault();
        e.stopPropagation();
        elDrop.classList.remove('dragover');
      });
    });

    elDrop.addEventListener('drop', (e) => {
      const dt = e.dataTransfer;
      if (!dt) return;
      const file = dt.files && dt.files[0];
      if (!file) return;
      if (!/\.zip$/i.test(file.name) && file.type !== 'application/zip') {
        setStatus('Please drop a .zip file.', 'bad');
        return;
      }
      handleZipFile(file);
    });

    window.addEventListener('dragover', (e) => e.preventDefault());
    window.addEventListener('drop', (e) => e.preventDefault());

    // ---------------------------
    // Tests (no framework) — kept, but run silently (no diagnostics UI)
    // ---------------------------
    function assert(name, condition) {
      if (!condition) throw new Error(`Test failed: ${name}`);
      // If someone later reintroduces #tests, we'll also render results.
      if (elTests) {
        const line = document.createElement('div');
        line.textContent = '✔ ' + name;
        elTests.appendChild(line);
      }
    }

    function parseCsv(csv) {
      const rows = [];
      let cur = [];
      let field = '';
      let inQuotes = false;
      for (let i = 0; i < csv.length; i++) {
        const ch = csv[i];
        const next = csv[i + 1];
        if (inQuotes) {
          if (ch === '"' && next === '"') {
            field += '"';
            i++;
          } else if (ch === '"') {
            inQuotes = false;
          } else {
            field += ch;
          }
        } else {
          if (ch === '"') {
            inQuotes = true;
          } else if (ch === ',') {
            cur.push(field);
            field = '';
          } else if (ch === '\n') {
            cur.push(field);
            rows.push(cur);
            cur = [];
            field = '';
          } else if (ch === '\r') {
            // ignore
          } else {
            field += ch;
          }
        }
      }
      cur.push(field);
      rows.push(cur);
      return rows;
    }

    function runTests() {
      // Test 1: header + root + instance grouping + per-row parenting
      {
        const zipName = 'sample.zip';
        const rows = [
          { instance: 'a', query_name: 'q1', cypher: 'MATCH (n) RETURN n', total_exec_time_ms: '1' },
          { instance: 'a', query_name: 'q2', cypher: 'RETURN 2', total_exec_time_ms: '2' },
          { instance: 'b', query_name: 'q3', cypher: 'RETURN 3', total_exec_time_ms: '3' },
        ];
        const { csv } = buildExportCsv(zipName, rows);
        const parsed = parseCsv(csv);

        assert('CSV has header', parsed[0].join(',') === 'name,description,query,id,parentId,isFolder');
        assert('CSV has root + 2 instances + 3 rows = 6 lines total', parsed.length === 1 + 1 + 2 + 3);

        const header = parsed[0];
        const idx = Object.fromEntries(header.map((h, i) => [h, i]));

        const rootLine = parsed[1];
        const rootId = rootLine[idx.id];
        assert('Root line name == zip filename', rootLine[idx.name] === zipName);
        assert('Root line isFolder == true', rootLine[idx.isFolder] === 'true');
        assert('Root line parentId empty', rootLine[idx.parentId] === '');
        assert('Root line has id', !!rootId);

        // next 2 lines are instance folders (sorted: a then b)
        const instA = parsed[2];
        const instB = parsed[3];
        assert('Instance folder A parentId == rootId', instA[idx.parentId] === rootId);
        assert('Instance folder B parentId == rootId', instB[idx.parentId] === rootId);
        assert('Instance folder isFolder == true', instA[idx.isFolder] === 'true' && instB[idx.isFolder] === 'true');
        assert('Instance folder names are a then b', instA[idx.name] === 'a' && instB[idx.name] === 'b');

        const aId = instA[idx.id];
        const bId = instB[idx.id];

        const leaf1 = parsed[4];
        const leaf2 = parsed[5];
        const leaf3 = parsed[6];

        assert('Leaf lines have isFolder == false', leaf1[idx.isFolder] === 'false' && leaf2[idx.isFolder] === 'false' && leaf3[idx.isFolder] === 'false');
        assert('Leaf parentIds map to correct instance folder',
          (leaf1[idx.parentId] === aId) &&
          (leaf2[idx.parentId] === aId) &&
          (leaf3[idx.parentId] === bId)
        );

        assert('Leaf query column contains cypher', leaf1[idx.query] === 'MATCH (n) RETURN n');
      }

      // Test 1b: sorting by instance then query_name (ascending)
      {
        const rows = [
          { instance: 'b', query_name: 'bq', cypher: '', total_exec_time_ms: '0' },
          { instance: 'a', query_name: 'zq', cypher: '', total_exec_time_ms: '0' },
          { instance: 'a', query_name: 'aq', cypher: '', total_exec_time_ms: '0' },
          { instance: 'b', query_name: 'aq', cypher: '', total_exec_time_ms: '0' },
        ];
        rows.sort((a, b) => {
          const ai = (a.instance ?? '').localeCompare(b.instance ?? '');
          if (ai !== 0) return ai;
          return (a.query_name ?? '').localeCompare(b.query_name ?? '');
        });
        const order = rows.map(r => `${r.instance}/${r.query_name}`).join('|');
        assert('Sort order is a/aq, a/zq, b/aq, b/bq', order === 'a/aq|a/zq|b/aq|b/bq');
      }

      // Test 2: CSV escaping for commas/quotes/newlines
      {
        const zipName = 'z.zip';
        const rows = [
          { instance: 'inst', query_name: 'name,with,commas', cypher: 'RETURN "a,b"\nRETURN 2', total_exec_time_ms: '0' },
        ];
        const { csv } = buildExportCsv(zipName, rows);
        const parsed = parseCsv(csv);
        const header = parsed[0];
        const idx = Object.fromEntries(header.map((h, i) => [h, i]));

        // root + inst + leaf
        assert('Escaping test has 4 lines', parsed.length === 4);
        assert('Query name preserved after parse', parsed[3][idx.name] === 'name,with,commas');
        assert('Cypher preserved after parse', parsed[3][idx.query] === 'RETURN "a,b"\nRETURN 2');
      }

      // Test 3: empty/blank instance values should not create instance folders
      {
        const rows = [
          { instance: '', query_name: 'q', cypher: 'RETURN 1', total_exec_time_ms: '0' },
          { instance: '   ', query_name: 'q2', cypher: 'RETURN 2', total_exec_time_ms: '0' },
        ];
        const { csv } = buildExportCsv('x.zip', rows);
        const parsed = parseCsv(csv);
        // header + root + 2 leaf rows (no instance folders) = 4
        assert('Blank instances do not create folders', parsed.length === 4);
      }
      // Test 4: param companion line added after queries containing $parameters
      {
        const rows = [
          { instance: 'i', query_name: 'Q', cypher: 'MATCH (n) WHERE n.id = $id AND n.name = $name RETURN n', total_exec_time_ms: '0' },
          { instance: 'i', query_name: 'NoParams', cypher: 'RETURN 1', total_exec_time_ms: '0' },
        ];
        const { csv } = buildExportCsv('p.zip', rows);
        const parsed = parseCsv(csv);
        const header = parsed[0];
        const idx = Object.fromEntries(header.map((h, i) => [h, i]));

        // header + root + instance folder + Q + Q params + NoParams = 6
        assert('Param companion adds one extra line', parsed.length === 6);
        assert('Companion line name is "Q set parameters"', parsed[4][idx.name] === 'Q set parameters');
        assert('Companion line query starts with :param', parsed[4][idx.query].startsWith(':param {'));
        assert('Companion line isFolder is false', parsed[4][idx.isFolder] === 'false');
        assert('Companion line parentId equals main query parentId', parsed[4][idx.parentId] === parsed[3][idx.parentId]);
      }

    }

    try {
      runTests();
    } catch (e) {
      console.warn(e);
    }
  </script>
</body>
</html>
