<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Rolling Distribution Histogram</title>
  <script src="https://cdn.plot.ly/plotly-2.30.0.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <style>
    :root { --bg:#0b1220; --panel:#101b32; --text:#e8eefc; --muted:#9bb0db; --accent:#7aa2ff; --border:rgba(255,255,255,.12); }
    html,body{height:100%;}
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;background:linear-gradient(180deg,var(--bg),#060a14);color:var(--text);}
    .wrap{max-width:1400px;margin:0 auto;padding:24px;display:flex;flex-direction:column;gap:16px;}
    .top{display:grid;grid-template-columns:1fr 1fr;gap:16px;align-items:start;}
    @media (max-width: 980px){.top{grid-template-columns:1fr;}}
    .card{background:rgba(16,27,50,.85);border:1px solid var(--border);border-radius:18px;box-shadow:0 10px 35px rgba(0,0,0,.35);}
    .card .hd{padding:16px 16px 10px;border-bottom:1px solid var(--border);display:flex;align-items:center;justify-content:space-between;gap:12px;}
    .card .hd h1{font-size:16px;margin:0;letter-spacing:.2px;}
    .card .hd .sub{font-size:12px;color:var(--muted);}
    .card .bd{padding:16px;}
    .drop{border:1px dashed rgba(255,255,255,.25);border-radius:16px;padding:18px;display:flex;flex-direction:column;gap:10px;align-items:flex-start;justify-content:center;min-height:120px;background:rgba(0,0,0,.12);}
    .drop.dragover{border-color:var(--accent);background:rgba(122,162,255,.12);}
    .btn{appearance:none;border:1px solid rgba(255,255,255,.18);background:rgba(255,255,255,.08);color:var(--text);padding:10px 12px;border-radius:12px;cursor:pointer;font-weight:600;}
    .btn:hover{border-color:rgba(255,255,255,.28);}
    .btn:active{background:rgba(255,255,255,.15);}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center;}
    .pill{font-size:12px;border:1px solid rgba(255,255,255,.18);border-radius:999px;padding:6px 10px;color:var(--muted);}
    label{font-size:12px;color:var(--muted);}
    select,input[type="number"],input[type="range"]{accent-color:var(--accent);}
    input[type="number"]{width:80px;padding:6px;border:1px solid var(--border);border-radius:6px;background:rgba(0,0,0,.2);color:var(--text);}
    input[type="text"]{padding:6px;border:1px solid var(--border);border-radius:6px;background:rgba(0,0,0,.2);color:var(--text);}
    .form-group{display:flex;flex-direction:column;gap:4px;}
    .form-row{display:flex;gap:16px;flex-wrap:wrap;align-items:end;}
    .control-group{display:flex;gap:8px;align-items:center;}
    .animation-controls{display:flex;gap:8px;align-items:center;flex-wrap:wrap;}
    .slider-container{flex:1;min-width:200px;}
    .time-display{font-size:12px;color:var(--accent);min-width:120px;text-align:center;}
    #plot{height:600px;}
    .hint{font-size:12px;color:var(--muted);line-height:1.35;}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;font-size:12px;color:#cdd9ff;}
    .status{font-size:12px;color:var(--muted);margin-top:8px;}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="top">
      <div class="card">
        <div class="hd">
          <div>
            <h1>Data Input</h1>
            <div class="sub">Drop CSV, JSONL, or Log file. Auto-detects timestamps and numerical values.</div>
          </div>
          <div class="row">
            <button class="btn" id="clearBtn" title="Clear data">Clear</button>
          </div>
        </div>
        <div class="bd">
          <div class="drop" id="dropZone">
            <div class="row">
              <button class="btn" id="pickBtn">Choose file…</button>
              <input id="fileInput" type="file" accept=".csv,.tsv,.json,.jsonl,.txt,.log" style="display:none" />
              <button class="btn" id="pasteBtn">Paste from clipboard</button>
              <span class="pill" id="dataStatus">No data loaded</span>
            </div>
            <div class="hint">
              <div>Supported formats:</div>
              <ul style="margin:4px 0 8px 16px; padding:0;">
                <li><strong>CSV/TSV:</strong> First column timestamp, others numerical.</li>
                <li><strong>JSONL:</strong> Line-separated JSON objects (needs "time" field).</li>
                <li><strong>Logs:</strong> Neo4j query logs (extracts ms, planning, waiting, bytes, etc).</li>
              </ul>
            </div>
          </div>
        </div>
      </div>

      <div class="card">
        <div class="hd">
          <div>
            <h1>Configuration</h1>
            <div class="sub">Set histogram parameters, filters, and animation settings</div>
          </div>
        </div>
        <div class="bd">
          <div class="form-row">
            <div class="form-group">
              <label for="columnSelect">Value Column</label>
              <select id="columnSelect" class="btn" style="padding:8px 10px">
                <option value="">Select column...</option>
              </select>
            </div>

            <div class="form-group">
              <label for="binCount">Bin Count</label>
              <input id="binCount" type="number" min="5" max="100" value="20" />
            </div>

            <div class="form-group">
              <label for="windowSize">Window Size (minutes)</label>
              <input id="windowSize" type="number" min="1" max="1440" value="1" />
            </div>
            <div class="form-group">
                <label for="lockAxes">Lock X-Axis</label>
                <div class="control-group">
                    <input id="lockAxes" type="checkbox" style="width:20px;height:20px;" checked>
                </div>
            </div>
          </div>

          <div style="height:16px"></div>

          <div style="font-size:14px;font-weight:600;color:var(--text);margin-bottom:8px;">Filter</div>
          <div class="form-row">
            <div class="form-group">
              <label for="filterColumn">Filter Column</label>
              <select id="filterColumn" class="btn" style="padding:8px 10px">
                <option value="">No filter</option>
              </select>
            </div>

            <div class="form-group">
              <label for="filterPredicate">Predicate</label>
              <select id="filterPredicate" class="btn" style="padding:8px 10px">
                <option value="equals">Equals</option>
                <option value="contains">Contains</option>
              </select>
            </div>

            <div class="form-group">
              <label for="filterValue">Filter Value</label>
              <input id="filterValue" type="text" placeholder="Enter filter value" style="width:120px;" />
            </div>
          </div>

          <div style="height:16px"></div>

          <div style="font-size:14px;font-weight:600;color:var(--text);margin-bottom:8px;">Group By</div>
          <div class="form-row">
            <div class="form-group">
              <label for="groupByColumn">Group Column</label>
              <select id="groupByColumn" class="btn" style="padding:8px 10px">
                <option value="">No grouping</option>
              </select>
            </div>
          </div>
          
          <div style="height:16px"></div>
          <div style="font-size:14px;font-weight:600;color:var(--text);margin-bottom:8px;">Animation</div>
          <div class="form-row">
            <div class="form-group">
                <label for="stepSize">Step Size (s)</label>
                <input id="stepSize" type="number" min="1" max="3600" value="60" />
            </div>
            <div class="form-group">
                <label for="speed">Speed (ms)</label>
                <input id="speed" type="number" min="10" max="2000" value="500" />
            </div>
          </div>

          <div style="height:16px"></div>

          <div class="animation-controls" style="justify-content: space-between;">
            <div class="control-group">
              <button class="btn" id="rewindBtn" title="Rewind" style="font-size:18px; padding:6px 14px;">⏮</button>
              <button class="btn" id="playBtn" title="Play" style="font-size:18px; padding:6px 14px;">▶</button>
              <button class="btn" id="pauseBtn" title="Pause" disabled style="font-size:18px; padding:6px 14px;">⏸</button>
            </div>
            
            <div class="time-display" id="timeDisplay" style="font-family:monospace; font-size:14px;">--:--</div>
          </div>

          <div class="slider-container" style="width:100%; margin-top:12px; margin-bottom:0px;">
            <input id="timeSlider" type="range" min="0" max="100" value="0" style="width:100%; display:block; cursor:pointer;" />
          </div>

          <div id="timelinePlot" style="height:120px; border-top:1px solid var(--border); padding-top:0;"></div>
          <div class="status" id="statusText">Ready to load data</div>
        </div>
      </div>
    </div>

    <div class="card">
      <div class="hd">
        <div>
          <h1>Rolling Distribution</h1>
          <div class="sub">Animated histogram of selected column over rolling time window</div>
        </div>
      </div>
      <div class="bd" style="padding:0">
        <div id="plot"></div>
      </div>
    </div>
  </div>

<script>
(() => {
  const state = {
    data: null, // Array of objects with timestamp and values
    columns: [],
    currentTimeIndex: 0,
    isPlaying: false,
    animationId: null,
    timestampColumn: null,
    valueColumns: [],
    categoryColumns: [],
    groupColorMap: {},
    currentGroupCol: null
  };

  const $ = (id) => document.getElementById(id);
  const dropZone = $('dropZone');
  const pickBtn = $('pickBtn');
  const fileInput = $('fileInput');
  const pasteBtn = $('pasteBtn');
  const dataStatus = $('dataStatus');
  const clearBtn = $('clearBtn');
  const columnSelect = $('columnSelect');
  const binCount = $('binCount');
  const windowSize = $('windowSize');
  const stepSize = $('stepSize');
  const speed = $('speed');
  const filterColumn = $('filterColumn');
  const filterPredicate = $('filterPredicate');
  const filterValue = $('filterValue');
  const playBtn = $('playBtn');
  const pauseBtn = $('pauseBtn');
  const rewindBtn = $('rewindBtn');
  const timeSlider = $('timeSlider');
  const timeDisplay = $('timeDisplay');
  const statusText = $('statusText');

  function updateStatus(text) {
    statusText.textContent = text;
  }

  // --- PARSING HELPERS ---

  function coerceTimestamp(value) {
    if (value === null || value === undefined) return null;
    const s = value.toString().trim();
    if (s === '') return null;

    const n = Number(s);
    if (Number.isFinite(n)) {
      const ms = n >= 1e12 ? n : n * 1000; // ms vs seconds
      return new Date(ms);
    }

    const t = Date.parse(s);
    return Number.isNaN(t) ? null : new Date(t);
  }

  function toNumber(v) {
    if (v === null || v === undefined) return NaN;
    const s = v.toString().trim();
    if (s === '') return NaN;
    const n = Number(s);
    return Number.isFinite(n) ? n : NaN;
  }

  // --- NEW PARSERS ---

  function parseJsonl(text) {
    const lines = text.split(/\r?\n/);
    const parsed = [];
    
    for (const line of lines) {
        if (!line.trim()) continue;
        try {
            const obj = JSON.parse(line);
            // Flatten top-level structure simply or use as is
            // We look for specific time fields
            const timeVal = obj.time || obj.timestamp || obj.date || obj.datetime;
            const ts = coerceTimestamp(timeVal);
            
            if (ts) {
                obj.timestamp = ts;
                parsed.push(obj);
            }
        } catch (e) {
            // Skip invalid lines
        }
    }
    return parsed;
  }

  function parseTextLog(text) {
    const lines = text.split(/\r?\n/);
    const parsed = [];
    
    // Regex for typical Neo4j query log start: "YYYY-MM-DD HH:mm:ss.SSS+0000 INFO ..."
    // Matches the timestamp at the very start of the line.
    const timestampRegex = /^(\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}\.\d{3}[+-]\d{4})/;
    
    // Metrics Extractors
    // "6 ms"
    const regexTime = /(\d+)\s+ms/; 
    // "planning: 6"
    const regexPlanning = /planning:\s*(\d+)/;
    // "waiting: 0"
    const regexWaiting = /waiting:\s*(\d+)/;
    // "0 B" or "Allocated: 500 B" - Looking for the pattern "- X B -" often seen in logs
    // or just digits followed by B. Let's be reasonably specific based on example " - 0 B -"
    const regexBytes = /-\s*(\d+)\s+B/; 
    // "0 page hits"
    const regexPageHits = /(\d+)\s+page hits/;
    // "0 page faults"
    const regexPageFaults = /(\d+)\s+page faults/;

    for (const line of lines) {
        const match = line.match(timestampRegex);
        if (match) {
            const tsStr = match[1];
            const ts = coerceTimestamp(tsStr);
            if (!ts) continue;

            const row = { timestamp: ts };

            // Extract Metrics
            const mTime = line.match(regexTime);
            if (mTime) row['elapsedTimeMs'] = parseInt(mTime[1]);

            const mPlan = line.match(regexPlanning);
            if (mPlan) row['planning'] = parseInt(mPlan[1]);

            const mWait = line.match(regexWaiting);
            if (mWait) row['waiting'] = parseInt(mWait[1]);

            const mBytes = line.match(regexBytes);
            if (mBytes) row['used bytes'] = parseInt(mBytes[1]);

            const mHits = line.match(regexPageHits);
            if (mHits) row['page hits'] = parseInt(mHits[1]);

            const mFaults = line.match(regexPageFaults);
            if (mFaults) row['page faults'] = parseInt(mFaults[1]);

            // Add original line for context if needed, or other fields
            // row['raw'] = line; 

            parsed.push(row);
        }
    }
    return parsed;
  }

  function parseData(rawData) {
    // 1. Determine Input Type
    let dataObjects = [];
    let headers = [];

    // Case A: CSV/TSV (Array of Arrays from PapaParse)
    if (Array.isArray(rawData) && Array.isArray(rawData[0])) {
        if (rawData.length < 2) throw new Error('CSV must have header and data');
        headers = rawData[0].map(h => (h ?? '').toString().trim());
        const rows = rawData.slice(1);
        
        dataObjects = rows.map(row => {
            const obj = {};
            headers.forEach((h, i) => {
                if (i === 0) obj.timestamp = coerceTimestamp(row[i]);
                else {
                    const val = row[i];
                    const num = toNumber(val);
                    obj[h] = Number.isNaN(num) ? (val ?? '').toString() : num;
                }
            });
            return obj;
        }).filter(r => r.timestamp !== null);
    } 
    // Case B: JSONL/Text Logs (Array of Objects)
    else if (Array.isArray(rawData) && typeof rawData[0] === 'object') {
        dataObjects = rawData.sort((a,b) => a.timestamp - b.timestamp);
        if (dataObjects.length === 0) throw new Error('No valid rows parsed');
        
        // Infer headers from the first valid object (or merge keys from sample)
        const sampleKeys = new Set();
        dataObjects.slice(0, 50).forEach(o => Object.keys(o).forEach(k => sampleKeys.add(k)));
        headers = Array.from(sampleKeys);
    } else {
        throw new Error('Unknown data format');
    }

    if (dataObjects.length === 0) throw new Error('No valid timestamped rows found');

    // 2. Classify Columns
    const valueCols = [];
    const categoryCols = [];
    const timestampCol = headers.find(h => h.toLowerCase() === 'timestamp' || h.toLowerCase() === 'time') || headers[0];

    const sampleLimit = Math.min(dataObjects.length, 50);

    headers.forEach(h => {
        if (!h || h === 'timestamp' || h === timestampCol) return;
        
        let numCount = 0;
        let strCount = 0;

        for(let i=0; i<sampleLimit; i++) {
            const v = dataObjects[i][h];
            if (typeof v === 'number') numCount++;
            else if (typeof v === 'string') strCount++;
        }

        if (numCount >= strCount && numCount > 0) valueCols.push(h);
        else categoryCols.push(h);
    });

    if (valueCols.length === 0) throw new Error('No numerical columns found');

    return {
        data: dataObjects,
        timestampColumn: timestampCol,
        valueColumns: valueCols,
        categoryColumns: categoryCols
    };
  }

  // --- APP LOGIC ---

  function updateColumnSelect() {
    columnSelect.innerHTML = '<option value="">Select column...</option>';
    filterColumn.innerHTML = '<option value="">No filter</option>';
    const groupByColumn = $('groupByColumn'); 
    groupByColumn.innerHTML = '<option value="">No grouping</option>'; 
    
    if (state.valueColumns.length > 0) {
      state.valueColumns.forEach(col => {
        const option = document.createElement('option');
        option.value = col;
        option.textContent = col;
        columnSelect.appendChild(option);
      });
      // Auto-select first value column
      columnSelect.value = state.valueColumns[0];
    }
    
    if (state.categoryColumns.length > 0) {
      state.categoryColumns.forEach(col => {
        const option = document.createElement('option');
        option.value = col;
        option.textContent = col;
        groupByColumn.appendChild(option);
      });
    }

    const allCols = [...state.valueColumns, ...state.categoryColumns];
    if (state.timestampColumn) {
      const tsOption = document.createElement('option');
      tsOption.value = 'timestamp';
      tsOption.textContent = state.timestampColumn + ' (timestamp)';
      filterColumn.appendChild(tsOption);
    }
    
    allCols.forEach(col => {
      const option = document.createElement('option');
      option.value = col;
      option.textContent = col;
      filterColumn.appendChild(option);
    });
  }

  function loadData(parsed) {
    state.data = parsed.data;
    state.timestampColumn = parsed.timestampColumn;
    state.valueColumns = parsed.valueColumns;
    state.categoryColumns = parsed.categoryColumns;
    state.currentTimeIndex = 0;
    state.isPlaying = false;
    state.groupColorMap = {};
    state.currentGroupCol = null;

    updateColumnSelect();
    updateDataStatus();
    updateTimeControls();
    updateStatus('Data loaded successfully');

    drawTimeline();
    drawHistogram(); // Draw initial frame
  }

  function updateDataStatus() {
    if (!state.data) {
      dataStatus.textContent = 'No data loaded';
      dataStatus.className = 'pill';
      return;
    }
    const count = state.data.length;
    const start = state.data[0].timestamp.toISOString().slice(0, 19);
    const end = state.data[count - 1].timestamp.toISOString().slice(0, 19);
    dataStatus.textContent = `${count} rows - ${start} to ${end}`;
    dataStatus.className = 'pill';
  }

  function updateTimeControls() {
    if (!state.data) {
      timeSlider.disabled = true;
      timeSlider.max = 100;
      timeSlider.value = 0;
      timeDisplay.textContent = '--:--';
      return;
    }
    const maxIndex = Math.max(0, state.data.length - 1);
    timeSlider.max = maxIndex;
    timeSlider.value = state.currentTimeIndex;
    timeSlider.disabled = false;
    const currentTime = state.data[state.currentTimeIndex]?.timestamp;
    if (currentTime) timeDisplay.textContent = currentTime.toISOString().slice(0, 19);
  }

  function getWindowData(currentIndex) {
    if (!state.data || !columnSelect.value) return [];
    const windowMinutes = parseInt(windowSize.value) || 1;
    const currentTime = state.data[currentIndex].timestamp;
    const windowStart = new Date(currentTime.getTime() - windowMinutes * 60 * 1000);
    const groupCol = $('groupByColumn').value;
    const windowData = [];
    
    for (let i = currentIndex; i >= 0; i--) {
      const row = state.data[i];
      if (row.timestamp < windowStart) break;

      if (filterColumn.value && filterValue.value.trim()) {
        const filterCol = filterColumn.value;
        const filterVal = filterValue.value.trim();
        let rowValue;
        if (filterCol === 'timestamp') rowValue = row.timestamp.toISOString();
        else rowValue = (row[filterCol] ?? '').toString();
        const matches = filterPredicate.value === 'equals' 
          ? rowValue === filterVal
          : rowValue.toLowerCase().includes(filterVal.toLowerCase());
        if (!matches) continue;
      }

      const val = row[columnSelect.value];
      if (typeof val === 'number' && Number.isFinite(val)) {
        windowData.push({
          value: val,
          group: groupCol ? (row[groupCol] ?? 'Unknown') : null
        });
      }
    }
    return windowData;
  }

  function calculatePercentile(sortedValues, q) {
    if (sortedValues.length === 0) return 0;
    const pos = (sortedValues.length - 1) * q;
    const base = Math.floor(pos);
    const rest = pos - base;
    return (sortedValues[base + 1] !== undefined)
      ? sortedValues[base] + rest * (sortedValues[base + 1] - sortedValues[base])
      : sortedValues[base];
  }

  function generateColorMap(colName) {
    if (!state.data) return {};
    const uniqueValues = new Set();
    state.data.forEach(row => uniqueValues.add((row[colName] ?? 'Unknown').toString()));
    const sortedGroups = Array.from(uniqueValues).sort();
    const colors = ['#636efa', '#EF553B', '#00cc96', '#ab63fa', '#FFA15A', '#19d3f3', '#FF6692', '#B6E880', '#FF97FF', '#FECB52'];
    const map = {};
    sortedGroups.forEach((group, i) => map[group] = colors[i % colors.length]);
    return map;
  }

  function drawTimeline() {
    if (!state.data || state.data.length === 0) {
      Plotly.react('timelinePlot', [], { paper_bgcolor: 'rgba(0,0,0,0)', plot_bgcolor: 'rgba(0,0,0,0)', xaxis: { showgrid: false, showticklabels: false }, yaxis: { showgrid: false, showticklabels: false } });
      return;
    }
    const totalStart = state.data[0].timestamp.getTime();
    const totalEnd = state.data[state.data.length - 1].timestamp.getTime();
    const totalDuration = totalEnd - totalStart;
    const binCountTarget = 100;
    const binStepMs = totalDuration <= 0 ? 1000 : totalDuration / binCountTarget;
    const groupByColumn = $('groupByColumn');
    const groupColName = groupByColumn ? groupByColumn.value : "";
    const isGrouping = groupColName !== "";

    const bins = new Map();
    state.data.forEach(row => {
        const t = row.timestamp.getTime();
        const binIdx = Math.floor((t - totalStart) / binStepMs);
        const g = isGrouping ? (row[groupColName] ?? 'Unknown').toString() : 'All';
        if (!bins.has(binIdx)) bins.set(binIdx, {});
        const binObj = bins.get(binIdx);
        binObj[g] = (binObj[g] || 0) + 1;
    });

    const allGroups = isGrouping ? Object.keys(state.groupColorMap).sort() : ['All'];
    const sortedBinIndices = Array.from(bins.keys()).sort((a, b) => a - b);
    const xValues = sortedBinIndices.map(i => new Date(totalStart + i * binStepMs + binStepMs/2));
    const traces = allGroups.map(groupName => {
        const yValues = sortedBinIndices.map(i => bins.get(i)[groupName] || 0);
        const color = isGrouping ? state.groupColorMap[groupName] : 'rgba(122,162,255,0.5)';
        return { type: 'bar', name: groupName, x: xValues, y: yValues, marker: { color: color }, hoverinfo: 'none' };
    });

    const layout = {
        barmode: 'stack', margin: { l: 0, r: 0, t: 10, b: 0 }, 
        paper_bgcolor: 'rgba(0,0,0,0)', plot_bgcolor: 'rgba(0,0,0,0)', showlegend: false,
        xaxis: { type: 'date', range: [totalStart, totalEnd], fixedrange: true, showgrid: false, showticklabels: false },
        yaxis: { fixedrange: true, showgrid: false, showticklabels: false, zeroline: false },
        hovermode: false, dragmode: false, shapes: [] 
    };
    Plotly.react('timelinePlot', traces, layout, { displayModeBar: false, responsive: true, staticPlot: true });
    updateTimelineHighlight();
  }

  function updateTimelineHighlight() {
    if (!state.data || state.data.length === 0) return;
    const endTime = state.data[state.currentTimeIndex].timestamp;
    const wMinutes = parseInt(windowSize.value) || 1;
    const startTime = new Date(endTime.getTime() - wMinutes * 60 * 1000);
    const windowShape = { type: 'rect', xref: 'x', yref: 'paper', x0: startTime, x1: endTime, y0: 0, y1: 1, fillcolor: '#fff', opacity: 0.15, line: { color: '#fff', width: 1 } };
    Plotly.relayout('timelinePlot', { shapes: [windowShape] });
  }

  function drawHistogram() {
    if (!state.data || !columnSelect.value) {
      Plotly.react('plot', [], { paper_bgcolor: 'rgba(0,0,0,0)', plot_bgcolor: 'rgba(0,0,0,0)', font: { color: '#e8eefc' } });
      return;
    }
    const lockAxes = $('lockAxes').checked;
    const groupByColumn = $('groupByColumn');
    const groupColName = groupByColumn ? groupByColumn.value : "";
    const isGrouping = groupColName !== "";
    if (isGrouping && state.currentGroupCol !== groupColName) {
        state.groupColorMap = generateColorMap(groupColName);
        state.currentGroupCol = groupColName;
    }
    const windowData = getWindowData(state.currentTimeIndex);
    const endTime = state.data[state.currentTimeIndex].timestamp;
    const wMinutes = parseInt(windowSize.value) || 1;
    const startTime = new Date(endTime.getTime() - wMinutes * 60 * 1000);
    const fmt = (d) => d.toISOString().slice(0, 19).replace('T', ' ');

    if (windowData.length === 0) {
       const layout = {
        title: { text: `Distribution of ${columnSelect.value}<br><span style="font-size:12px;color:#9bb0db">${fmt(startTime)} — ${fmt(endTime)} (n=0)</span>`, font: { color: '#e8eefc' } },
        paper_bgcolor: 'rgba(0,0,0,0)', plot_bgcolor: 'rgba(0,0,0,0)', font: { color: '#e8eefc' },
        xaxis: { showgrid: false, zeroline: false, showticklabels: false },
        yaxis: { showgrid: false, zeroline: false, showticklabels: false }
      };
      Plotly.react('plot', [], layout);
      updateStatus('No data in current window');
      return;
    }

    const binCountVal = parseInt(binCount.value) || 20;
    let min, max, allValuesForStats;
    const windowValues = windowData.map(d => d.value).sort((a, b) => a - b);

    if (lockAxes) {
        let gMin = Infinity, gMax = -Infinity;
        const col = columnSelect.value;
        for (let i = 0; i < state.data.length; i++) {
            const v = state.data[i][col];
            if (typeof v === 'number' && Number.isFinite(v)) {
                if (v < gMin) gMin = v;
                if (v > gMax) gMax = v;
            }
        }
        min = gMin; max = gMax; allValuesForStats = windowValues;
    } else {
        min = windowValues[0]; max = windowValues[windowValues.length - 1]; allValuesForStats = windowValues;
    }

    const rangeSpan = max - min;
    const binSize = rangeSpan === 0 ? 1 : rangeSpan / binCountVal;
    const loops = rangeSpan === 0 ? 1 : binCountVal;
    const binRanges = [];
    for (let i = 0; i < loops; i++) {
        const start = min + i * binSize;
        const end = min + (i + 1) * binSize;
        const label = rangeSpan === 0 ? `${min}` : `${start.toFixed(2)} - ${end.toFixed(2)}`;
        const mid = (start + end) / 2;
        binRanges.push({ start, end, label, mid });
    }

    const groups = {};
    if (isGrouping) {
        windowData.forEach(d => {
            const g = (d.group ?? 'Unknown').toString();
            if (!groups[g]) groups[g] = [];
            groups[g].push(d.value);
        });
    } else { groups['All'] = windowValues; }

    const traces = Object.keys(groups).sort().map(groupName => {
        const values = groups[groupName];
        const counts = binRanges.map((bin, i) => {
            return values.filter(v => i === loops - 1 ? (v >= bin.start && v <= bin.end) : (v >= bin.start && v < bin.end)).length;
        });
        const traceColor = isGrouping ? state.groupColorMap[groupName] : 'rgba(122,162,255,0.8)';
        return {
            type: 'bar', name: groupName, x: binRanges.map(b => b.mid), y: counts,
            width: binRanges.map(b => (b.end - b.start)), 
            marker: { color: traceColor, line: { color: traceColor, width: 1 } },
            hovertemplate: `${isGrouping ? 'Group: ' + groupName + '<br>' : ''}Range: %{x}<br>Count: %{y}<extra></extra>`
        };
    });

    const p50 = calculatePercentile(allValuesForStats, 0.50);
    const p75 = calculatePercentile(allValuesForStats, 0.75);
    const p90 = calculatePercentile(allValuesForStats, 0.90);
    const p99 = calculatePercentile(allValuesForStats, 0.99);
    const percentileConfig = [
        { val: p50, label: 'p50', color: '#ffd700' }, { val: p75, label: 'p75', color: '#ff9900' },
        { val: p90, label: 'p90', color: '#ff6600' }, { val: p99, label: 'p99', color: '#ff3300' }
    ];
    const shapes = percentileConfig.map(p => ({ type: 'line', x0: p.val, x1: p.val, y0: 0, y1: 1, xref: 'x', yref: 'paper', line: { color: p.color, width: 2, dash: 'dot' } }));
    const annotations = percentileConfig.map(p => ({ x: p.val, y: 1, xref: 'x', yref: 'paper', text: p.label, showarrow: false, xanchor: 'left', yanchor: 'bottom', font: { color: p.color, size: 10 }, textangle: -90, yshift: 5 }));

    const layout = {
      title: { text: `Distribution of ${columnSelect.value}<br><span style="font-size:12px;color:#9bb0db">${fmt(startTime)} — ${fmt(endTime)} (n=${windowData.length})</span>`, font: { color: '#e8eefc' } },
      barmode: isGrouping ? 'stack' : 'group',
      xaxis: { title: 'Value', automargin: true, tickangle: -45, gridcolor: 'rgba(255,255,255,0.1)', linecolor: 'rgba(255,255,255,0.2)', tickcolor: 'rgba(255,255,255,0.2)', autorange: !lockAxes, range: lockAxes ? [min, max] : null },
      yaxis: { title: 'Count', automargin: true, gridcolor: 'rgba(255,255,255,0.1)', linecolor: 'rgba(255,255,255,0.2)', tickcolor: 'rgba(255,255,255,0.2)' },
      margin: { l: 50, r: 20, t: 80, b: 100 }, paper_bgcolor: 'rgba(0,0,0,0)', plot_bgcolor: 'rgba(0,0,0,0)', font: { color: '#e8eefc' },
      shapes: shapes, annotations: annotations, legend: { font: { color: '#e8eefc' }, orientation: 'h', y: -0.2 }
    };
    Plotly.react('plot', traces, layout, { responsive: true, displaylogo: false, modeBarButtonsToRemove: ['select2d','lasso2d'] });
    updateStatus(`Showing ${windowData.length} points from current window`);
    updateTimelineHighlight();
  }

  function animate() {
    if (!state.isPlaying) return;
    const stepSeconds = parseInt(stepSize.value) || 60;
    const stepMs = stepSeconds * 1000;
    let nextIndex = state.currentTimeIndex;
    const currentTime = state.data[state.currentTimeIndex].timestamp;
    for (let i = state.currentTimeIndex + 1; i < state.data.length; i++) {
      if (state.data[i].timestamp.getTime() >= currentTime.getTime() + stepMs) { nextIndex = i; break; }
    }
    if (nextIndex >= state.data.length - 1) { state.isPlaying = false; updatePlayPauseButtons(); updateStatus('Animation completed'); return; }
    state.currentTimeIndex = nextIndex;
    updateTimeControls();
    drawHistogram();
    const speedVal = parseInt(speed.value) || 500;
    state.animationId = setTimeout(animate, speedVal);
  }

  function startAnimation() {
    if (state.isPlaying) return;
    state.isPlaying = true;
    updatePlayPauseButtons();
    updateStatus('Animation playing...');
    animate();
  }
  function pauseAnimation() {
    state.isPlaying = false;
    if (state.animationId) { clearTimeout(state.animationId); state.animationId = null; }
    updatePlayPauseButtons();
    updateStatus('Animation paused');
  }
  function rewindAnimation() {
    pauseAnimation(); state.currentTimeIndex = 0;
    updateTimeControls(); drawHistogram(); updateStatus('Rewound to start');
  }
  function updatePlayPauseButtons() { playBtn.disabled = state.isPlaying; pauseBtn.disabled = !state.isPlaying; }

  // --- FILE HANDLING ---

  async function parseFileContent(text, fileName) {
    // 1. Try JSONL
    if (text.trim().startsWith('{') || (fileName && (fileName.endsWith('.json') || fileName.endsWith('.jsonl')))) {
        const jsonRes = parseJsonl(text);
        if (jsonRes.length > 0) return jsonRes;
    }
    
    // 2. Try Text Log (Timestamped lines)
    // Heuristic: Check if start of text matches timestamp regex
    if (/^\d{4}-\d{2}-\d{2}/.test(text) || (fileName && (fileName.endsWith('.log') || fileName.endsWith('.txt')))) {
        const logRes = parseTextLog(text);
        if (logRes.length > 0) return logRes;
    }

    // 3. Fallback to CSV (PapaParse)
    return new Promise((resolve, reject) => {
      Papa.parse(text, {
        skipEmptyLines: true, dynamicTyping: false,
        complete: (res) => resolve(res.data),
        error: (err) => reject(err)
      });
    });
  }

  async function addData(rawData) {
    try {
      const parsed = parseData(rawData);
      loadData(parsed);
    } catch (e) {
      updateStatus(`Error: ${e.message}`);
      console.error(e);
    }
  }

  const handleFile = async (file) => {
      if (!file) return;
      const reader = new FileReader();
      reader.onload = async (e) => {
          const text = e.target.result;
          try {
              const raw = await parseFileContent(text, file.name);
              await addData(raw);
          } catch (err) {
              updateStatus(`Error parsing file: ${err.message}`);
          }
      };
      reader.readAsText(file);
  };

  pickBtn.addEventListener('click', () => fileInput.click());
  fileInput.addEventListener('change', (e) => handleFile(e.target.files[0]));

  pasteBtn.addEventListener('click', async () => {
    try {
      const text = await navigator.clipboard.readText();
      const raw = await parseFileContent(text, 'clipboard.txt'); // Treat as generic text
      await addData(raw);
    } catch (e) { updateStatus(`Error reading clipboard: ${e.message}`); }
  });

  ['dragenter','dragover'].forEach(ev => dropZone.addEventListener(ev, (e) => { e.preventDefault(); e.stopPropagation(); dropZone.classList.add('dragover'); }));
  ['dragleave','drop'].forEach(ev => dropZone.addEventListener(ev, (e) => { e.preventDefault(); e.stopPropagation(); dropZone.classList.remove('dragover'); }));
  
  dropZone.addEventListener('drop', async (e) => {
    const dt = e.dataTransfer;
    if (dt && dt.files && dt.files[0]) {
      handleFile(dt.files[0]);
    }
  });

  // UI Event Listeners
  clearBtn.addEventListener('click', () => {
    state.data = null; state.columns = []; state.currentTimeIndex = 0; state.isPlaying = false;
    if (state.animationId) { clearTimeout(state.animationId); state.animationId = null; }
    updateColumnSelect(); updateDataStatus(); updateTimeControls(); updatePlayPauseButtons();
    filterColumn.value = ''; filterValue.value = '';
    drawHistogram(); drawTimeline(); updateStatus('Data cleared');
  });

  [columnSelect, binCount, windowSize, $('lockAxes')].forEach(el => {
    if(el) el.addEventListener('change', () => { if (state.data && columnSelect.value) drawHistogram(); });
  });

  [filterColumn, filterPredicate, filterValue].forEach(el => {
    el.addEventListener('change', () => { if (state.data && columnSelect.value) drawHistogram(); });
    if (el.type === 'text') el.addEventListener('input', () => { if (state.data && columnSelect.value) drawHistogram(); });
  });

  playBtn.addEventListener('click', startAnimation);
  pauseBtn.addEventListener('click', pauseAnimation);
  rewindBtn.addEventListener('click', rewindAnimation);
  
  groupByColumn.addEventListener('change', () => {
    if (state.data && columnSelect.value) {
      const groupColName = groupByColumn.value;
      if (state.currentGroupCol !== groupColName) {
         state.groupColorMap = generateColorMap(groupColName);
         state.currentGroupCol = groupColName;
      }
      drawHistogram(); drawTimeline();
    }
  });

  timeSlider.addEventListener('input', (e) => {
    pauseAnimation(); state.currentTimeIndex = parseInt(e.target.value);
    updateTimeControls(); drawHistogram();
  });

  // Init
  updateDataStatus(); updateTimeControls(); updatePlayPauseButtons(); drawHistogram();
})();
</script>
</body>
</html>